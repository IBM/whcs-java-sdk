<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AnnotatorForClinicalData.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">IBM Watson Health Cognitive Services Coverage Reports</a> &gt; <a href="../index.html" class="el_bundle">annotator-for-clinical-data</a> &gt; <a href="index.source.html" class="el_package">com.ibm.watson.health.acd.v1</a> &gt; <span class="el_source">AnnotatorForClinicalData.java</span></div><h1>AnnotatorForClinicalData.java</h1><pre class="source lang-java linenums">/*
 * (C) Copyright IBM Corp. 2020.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */
package com.ibm.watson.health.acd.v1;

import java.util.Map;
import java.util.Map.Entry;

import com.google.gson.JsonObject;
import com.ibm.cloud.sdk.core.http.RequestBuilder;
import com.ibm.cloud.sdk.core.http.Response;
import com.ibm.cloud.sdk.core.http.ResponseConverter;
import com.ibm.cloud.sdk.core.http.ServiceCall;
import com.ibm.cloud.sdk.core.security.Authenticator;
import com.ibm.cloud.sdk.core.security.ConfigBasedAuthenticatorFactory;
import com.ibm.cloud.sdk.core.service.BaseService;
import com.ibm.cloud.sdk.core.util.GsonSingleton;
import com.ibm.cloud.sdk.core.util.RequestUtils;
import com.ibm.cloud.sdk.core.util.ResponseConverterUtils;
import com.ibm.cloud.sdk.core.util.Validator;
import com.ibm.cloud.whcs.common.SdkCommon;
import com.ibm.watson.health.acd.v1.model.AcdCartridges;
import com.ibm.watson.health.acd.v1.model.AcdCartridgesList;
import com.ibm.watson.health.acd.v1.model.AcdFlow;
import com.ibm.watson.health.acd.v1.model.AcdProfile;
import com.ibm.watson.health.acd.v1.model.AnalyzeOptions;
import com.ibm.watson.health.acd.v1.model.AnalyzeWithFlowOptions;
import com.ibm.watson.health.acd.v1.model.Annotator;
import com.ibm.watson.health.acd.v1.model.AnnotatorFlow;
import com.ibm.watson.health.acd.v1.model.CartridgesGetIdOptions;
import com.ibm.watson.health.acd.v1.model.CartridgesGetOptions;
import com.ibm.watson.health.acd.v1.model.CartridgesPostMultipartOptions;
import com.ibm.watson.health.acd.v1.model.CartridgesPutMultipartOptions;
import com.ibm.watson.health.acd.v1.model.ContainerGroup;
import com.ibm.watson.health.acd.v1.model.CreateFlowsOptions;
import com.ibm.watson.health.acd.v1.model.CreateProfileOptions;
import com.ibm.watson.health.acd.v1.model.DeleteFlowsOptions;
import com.ibm.watson.health.acd.v1.model.DeleteProfileOptions;
import com.ibm.watson.health.acd.v1.model.DeleteUserSpecificArtifactsOptions;
import com.ibm.watson.health.acd.v1.model.DeployCartridgeOptions;
import com.ibm.watson.health.acd.v1.model.DeployCartridgeResponse;
import com.ibm.watson.health.acd.v1.model.Flow;
import com.ibm.watson.health.acd.v1.model.GetAnnotatorsByIdOptions;
import com.ibm.watson.health.acd.v1.model.GetAnnotatorsOptions;
import com.ibm.watson.health.acd.v1.model.GetFlowsByIdOptions;
import com.ibm.watson.health.acd.v1.model.GetFlowsOptions;
import com.ibm.watson.health.acd.v1.model.GetHealthCheckStatusOptions;
import com.ibm.watson.health.acd.v1.model.GetProfileOptions;
import com.ibm.watson.health.acd.v1.model.GetProfilesOptions;
import com.ibm.watson.health.acd.v1.model.ListStringWrapper;
import com.ibm.watson.health.acd.v1.model.RequestContainer;
import com.ibm.watson.health.acd.v1.model.RunPipelineOptions;
import com.ibm.watson.health.acd.v1.model.RunPipelineWithFlowOptions;
import com.ibm.watson.health.acd.v1.model.ServiceApiBean;
import com.ibm.watson.health.acd.v1.model.ServiceStatus;
import com.ibm.watson.health.acd.v1.model.UnstructuredContainer;
import com.ibm.watson.health.acd.v1.model.UpdateFlowsOptions;
import com.ibm.watson.health.acd.v1.model.UpdateProfileOptions;

import okhttp3.MultipartBody;

/**
 * Natural Language Processing (NLP) service featuring a set of medical domain annotators for use in detecting entities
 * and medical concepts from unstructured data. Multiple annotators may be invoked from a single request.
 *
 * @version v1
 */
public class AnnotatorForClinicalData extends BaseService {

  public static final String DEFAULT_SERVICE_NAME = &quot;annotator_for_clinical_data_acd&quot;;

  public static final String DEFAULT_SERVICE_URL = &quot;https://annotator-for-clinical-data-acd.cloud.ibm.com/services/clinical_data_annotator/api&quot;;

  public static final String RETURN_ANALYZED_TEXT = &quot;return_analyzed_text&quot;;

  public static final String VERSION = &quot;version&quot;;

  private String version;

 /**
   * Class method which constructs an instance of the `AnnotatorForClinicalDataAcd` client.
   * The default service name is used to configure the client instance.
   *
   * @param version The release date of the version of the API you want to use. Specify dates in YYYY-MM-DD format.
   * @return an instance of the `AnnotatorForClinicalDataAcd` client using external configuration
   */
  public static AnnotatorForClinicalData newInstance(String version) {
<span class="nc" id="L97">    return newInstance(version, DEFAULT_SERVICE_NAME);</span>
  }

  /**
   * Class method which constructs an instance of the `AnnotatorForClinicalDataAcd` client.
   * The specified service name is used to configure the client instance.
   *
   * @param version The release date of the version of the API you want to use. Specify dates in YYYY-MM-DD format.
   * @param serviceName the service name to be used when configuring the client instance
   * @return an instance of the `AnnotatorForClinicalDataAcd` client using external configuration
   */
  public static AnnotatorForClinicalData newInstance(String version, String serviceName) {
<span class="fc" id="L109">    Authenticator authenticator = ConfigBasedAuthenticatorFactory.getAuthenticator(serviceName);</span>
<span class="fc" id="L110">    AnnotatorForClinicalData service = new AnnotatorForClinicalData(version, serviceName, authenticator);</span>
<span class="fc" id="L111">    service.configureService(serviceName);</span>
<span class="fc" id="L112">    return service;</span>
  }

  /**
   * Constructs an instance of the `AnnotatorForClinicalDataAcd` client.
   * The specified service name and authenticator are used to configure the client instance.
   *
   * @param version The release date of the version of the API you want to use. Specify dates in YYYY-MM-DD format.
   * @param serviceName the service name to be used when configuring the client instance
   * @param authenticator the {@link Authenticator} instance to be configured for this client
   */
  public AnnotatorForClinicalData(String version, String serviceName, Authenticator authenticator) {
<span class="fc" id="L124">    super(serviceName, authenticator);</span>
<span class="fc" id="L125">    setServiceUrl(DEFAULT_SERVICE_URL);</span>
<span class="fc" id="L126">    setVersion(version);</span>
<span class="fc" id="L127">  }</span>

  /**
   * Gets the version.
   *
   * The release date of the version of the API you want to use. Specify dates in YYYY-MM-DD format.
   *
   * @return the version
   */
  public String getVersion() {
<span class="fc" id="L137">    return this.version;</span>
  }

  /**
   * Sets the version.
   *
   * @param version the new version
   */
  public void setVersion(final String version) {
<span class="fc" id="L146">    com.ibm.cloud.sdk.core.util.Validator.notEmpty(version, &quot;version cannot be empty.&quot;);</span>
<span class="fc" id="L147">    this.version = version;</span>
<span class="fc" id="L148">  }</span>

  /**
   * Get list of available persisted profiles.
   *
   * Returns a summary including ID and description of the available persisted profiles.
   *
   * @param getProfilesOptions the {@link GetProfilesOptions} containing the options for the call
   * @return a {@link ServiceCall} with a result of type {@link ListStringWrapper}
   */
  public ServiceCall&lt;Map&lt;String, AcdProfile&gt;&gt; getProfiles(GetProfilesOptions getProfilesOptions) {
<span class="fc" id="L159">	  String[] pathSegments = { &quot;v1/profiles&quot; };</span>
<span class="fc" id="L160">	  RequestBuilder builder = RequestBuilder.get(RequestBuilder.constructHttpUrl(getServiceUrl(), pathSegments));</span>
<span class="fc" id="L161">	  Map&lt;String, String&gt; sdkHeaders = SdkCommon.getSdkHeaders(&quot;annotator_for_clinical_data_acd&quot;, &quot;v1&quot;, &quot;getProfiles&quot;);</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">	  for (Entry&lt;String, String&gt; header : sdkHeaders.entrySet()) {</span>
<span class="fc" id="L163">		  builder.header(header.getKey(), header.getValue());</span>
<span class="fc" id="L164">	  }</span>
<span class="fc" id="L165">	  builder.header(&quot;Accept&quot;, &quot;application/json&quot;);</span>
<span class="fc" id="L166">	  builder.query(&quot;version&quot;, this.version);</span>
<span class="fc" id="L167">	  ResponseConverter&lt;Map&lt;String, AcdProfile&gt;&gt; responseConverter =</span>
<span class="fc" id="L168">			  ResponseConverterUtils.getValue(new com.google.gson.reflect.TypeToken&lt;Map&lt;String, AcdProfile&gt;&gt;() { }.getType());</span>
<span class="fc" id="L169">	  return createServiceCall(builder.build(), responseConverter);</span>
  }

  /**
   * Get list of available persisted profiles.
   *
   * Returns a summary including ID and description of the available persisted profiles.
   *
   * @return a {@link ServiceCall} with a result of type {@link ListStringWrapper}
   */
  public ServiceCall&lt;Map&lt;String, AcdProfile&gt;&gt; getProfiles() {
<span class="nc" id="L180">    return getProfiles(null);</span>
  }

  /**
   * Persist a new profile.
   *
   * This API persists a new profile.  A profile is identified by an ID.  This ID can optionally be specified as part of
   * the request body when invoking &amp;lt;b&amp;gt;POST /v1/analyze&amp;lt;/b&amp;gt; API.  A profile contains annotator configuration
   * information that will be applied to the annotators specified in the annotator flow.&amp;lt;p&amp;gt;If a caller would
   * choose to have the ID of the new profile generated on their behalf, then in the request body the &quot;id&quot; field of the
   * profile definition should be an empty string (&quot;&quot;).  The auto-generated ID would be a normalized form of the &quot;name&quot;
   * field from the profile definition.&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Sample Profile #1&amp;lt;/b&amp;gt;&amp;lt;br&amp;gt;A profile definition that
   * configures the 'concept_detection' annotator to use the UMLS umls.latest library.&amp;lt;br&amp;gt;&amp;lt;pre&amp;gt;{&amp;lt;br&amp;gt;
   * &quot;id&quot;: &quot;acd_profile_cd_umls_latest&quot;,&amp;lt;br&amp;gt;  &quot;name&quot;: &quot;Profile for the latest Concept Detection UMLS
   * Library&quot;,&amp;lt;br&amp;gt;  &quot;description&quot;: &quot;Provides configurations for running Concept Detection with the latest UMLS
   * library&quot;,&amp;lt;br&amp;gt;  &quot;annotators&quot;: [&amp;lt;br&amp;gt;    {&amp;lt;br&amp;gt;      &quot;name&quot;: &quot;concept_detection&quot;,&amp;lt;br&amp;gt;
   * &quot;parameters&quot;: {&amp;lt;br&amp;gt;         &quot;libraries&quot;: [&quot;umls.latest&quot;]&amp;lt;br&amp;gt;       }&amp;lt;br&amp;gt;    }&amp;lt;br&amp;gt;
   * ]&amp;lt;br&amp;gt;}&amp;lt;/pre&amp;gt;&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Sample Profile #2&amp;lt;/b&amp;gt;&amp;lt;br&amp;gt;A profile definition that configures
   * the 'concept_detection' annotator to exclude any annotations where the semantic type does not equal
   * 'neop'.&amp;lt;br&amp;gt;&amp;lt;pre&amp;gt;{&amp;lt;br&amp;gt;  &quot;id&quot;: &quot;acd_profile_cd_neop_only&quot;,&amp;lt;br&amp;gt;  &quot;name&quot;: &quot;Profile for Concept
   * Detection neop Semantic Type&quot;,&amp;lt;br&amp;gt;  &quot;description&quot;: &quot;Concept Detection configuration fitler to exclude
   * annotations where semantic type does not equal 'neop'.&quot;,&amp;lt;br&amp;gt;  &quot;annotators&quot;: [&amp;lt;br&amp;gt;    {&amp;lt;br&amp;gt;
   * &quot;name&quot;: &quot;concept_detection&quot;,&amp;lt;br&amp;gt;       &quot;configurations&quot;: [&amp;lt;br&amp;gt;         {&amp;lt;br&amp;gt;           &quot;filter&quot;:
   * {&amp;lt;br&amp;gt;             &quot;target&quot;: &quot;unstructured.data.concepts&quot;,&amp;lt;br&amp;gt;             &quot;condition&quot;: {&amp;lt;br&amp;gt;
   *           &quot;type&quot;: &quot;match&quot;,&amp;lt;br&amp;gt;                &quot;field&quot;: &quot;semanticType&quot;,&amp;lt;br&amp;gt;                &quot;values&quot;:
   * [&amp;lt;br&amp;gt;                   &quot;neop&quot;&amp;lt;br&amp;gt;                 ],&amp;lt;br&amp;gt;                &quot;not&quot;: false,&amp;lt;br&amp;gt;
   *               &quot;caseInsensitive&quot;: false,&amp;lt;br&amp;gt;                &quot;operator&quot;: &quot;equals&quot;&amp;lt;br&amp;gt;
   * }&amp;lt;br&amp;gt;            }&amp;lt;br&amp;gt;         }&amp;lt;br&amp;gt;       ]&amp;lt;br&amp;gt;    }&amp;lt;br&amp;gt;  ]&amp;lt;br&amp;gt;}&amp;lt;/pre&amp;gt;.
   *
   * @param createProfileOptions the {@link CreateProfileOptions} containing the options for the call
   * @return a {@link ServiceCall} with a void result
   */
  public ServiceCall&lt;Void&gt; createProfile(CreateProfileOptions createProfileOptions) {
<span class="fc" id="L213">    com.ibm.cloud.sdk.core.util.Validator.notNull(createProfileOptions,</span>
      &quot;createProfileOptions cannot be null&quot;);
<span class="fc" id="L215">    String[] pathSegments = { &quot;v1/profiles&quot; };</span>
<span class="fc" id="L216">    RequestBuilder builder = RequestBuilder.post(RequestBuilder.constructHttpUrl(getServiceUrl(), pathSegments));</span>
<span class="fc" id="L217">    Map&lt;String, String&gt; sdkHeaders = SdkCommon.getSdkHeaders(&quot;annotator_for_clinical_data_acd&quot;, &quot;v1&quot;, &quot;createProfile&quot;);</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">    for (Entry&lt;String, String&gt; header : sdkHeaders.entrySet()) {</span>
<span class="fc" id="L219">      builder.header(header.getKey(), header.getValue());</span>
<span class="fc" id="L220">    }</span>
<span class="fc" id="L221">    builder.query(&quot;version&quot;, this.version);</span>
<span class="fc" id="L222">    final JsonObject contentJson = new JsonObject();</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">    if (createProfileOptions.id() != null) {</span>
<span class="fc" id="L224">      contentJson.addProperty(&quot;id&quot;, createProfileOptions.id());</span>
    }
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">    if (createProfileOptions.name() != null) {</span>
<span class="fc" id="L227">      contentJson.addProperty(&quot;name&quot;, createProfileOptions.name());</span>
    }
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">    if (createProfileOptions.description() != null) {</span>
<span class="fc" id="L230">      contentJson.addProperty(&quot;description&quot;, createProfileOptions.description());</span>
    }
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">    if (createProfileOptions.publishedDate() != null) {</span>
<span class="fc" id="L233">      contentJson.addProperty(&quot;publishedDate&quot;, createProfileOptions.publishedDate());</span>
    }
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">    if (createProfileOptions.publish() != null) {</span>
<span class="fc" id="L236">      contentJson.addProperty(&quot;publish&quot;, createProfileOptions.publish());</span>
    }
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">    if (createProfileOptions.version() != null) {</span>
<span class="fc" id="L239">      contentJson.addProperty(&quot;version&quot;, createProfileOptions.version());</span>
    }
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">    if (createProfileOptions.cartridgeId() != null) {</span>
<span class="fc" id="L242">      contentJson.addProperty(&quot;cartridgeId&quot;, createProfileOptions.cartridgeId());</span>
    }
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">    if (createProfileOptions.annotators() != null) {</span>
<span class="fc" id="L245">      contentJson.add(&quot;annotators&quot;, com.ibm.cloud.sdk.core.util.GsonSingleton.getGson().toJsonTree(createProfileOptions.annotators()));</span>
    }
<span class="fc" id="L247">    builder.bodyJson(contentJson);</span>
<span class="fc" id="L248">    ResponseConverter&lt;Void&gt; responseConverter = ResponseConverterUtils.getVoid();</span>
<span class="fc" id="L249">    return createServiceCall(builder.build(), responseConverter);</span>
  }

  /**
   * Persist a new profile.
   *
   * This API persists a new profile.  A profile is identified by an ID.  This ID can optionally be specified as part of
   * the request body when invoking &amp;lt;b&amp;gt;POST /v1/analyze&amp;lt;/b&amp;gt; API.  A profile contains annotator configuration
   * information that will be applied to the annotators specified in the annotator flow.&amp;lt;p&amp;gt;If a caller would
   * choose to have the ID of the new profile generated on their behalf, then in the request body the &quot;id&quot; field of the
   * profile definition should be an empty string (&quot;&quot;).  The auto-generated ID would be a normalized form of the &quot;name&quot;
   * field from the profile definition.&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Sample Profile #1&amp;lt;/b&amp;gt;&amp;lt;br&amp;gt;A profile definition that
   * configures the 'concept_detection' annotator to use the UMLS umls.latest library.&amp;lt;br&amp;gt;&amp;lt;pre&amp;gt;{&amp;lt;br&amp;gt;
   * &quot;id&quot;: &quot;acd_profile_cd_umls_latest&quot;,&amp;lt;br&amp;gt;  &quot;name&quot;: &quot;Profile for the latest Concept Detection UMLS
   * Library&quot;,&amp;lt;br&amp;gt;  &quot;description&quot;: &quot;Provides configurations for running Concept Detection with the latest UMLS
   * library&quot;,&amp;lt;br&amp;gt;  &quot;annotators&quot;: [&amp;lt;br&amp;gt;    {&amp;lt;br&amp;gt;      &quot;name&quot;: &quot;concept_detection&quot;,&amp;lt;br&amp;gt;
   * &quot;parameters&quot;: {&amp;lt;br&amp;gt;         &quot;libraries&quot;: [&quot;umls.latest&quot;]&amp;lt;br&amp;gt;       }&amp;lt;br&amp;gt;    }&amp;lt;br&amp;gt;
   * ]&amp;lt;br&amp;gt;}&amp;lt;/pre&amp;gt;&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Sample Profile #2&amp;lt;/b&amp;gt;&amp;lt;br&amp;gt;A profile definition that configures
   * the 'concept_detection' annotator to exclude any annotations where the semantic type does not equal
   * 'neop'.&amp;lt;br&amp;gt;&amp;lt;pre&amp;gt;{&amp;lt;br&amp;gt;  &quot;id&quot;: &quot;acd_profile_cd_neop_only&quot;,&amp;lt;br&amp;gt;  &quot;name&quot;: &quot;Profile for Concept
   * Detection neop Semantic Type&quot;,&amp;lt;br&amp;gt;  &quot;description&quot;: &quot;Concept Detection configuration fitler to exclude
   * annotations where semantic type does not equal 'neop'.&quot;,&amp;lt;br&amp;gt;  &quot;annotators&quot;: [&amp;lt;br&amp;gt;    {&amp;lt;br&amp;gt;
   * &quot;name&quot;: &quot;concept_detection&quot;,&amp;lt;br&amp;gt;       &quot;configurations&quot;: [&amp;lt;br&amp;gt;         {&amp;lt;br&amp;gt;           &quot;filter&quot;:
   * {&amp;lt;br&amp;gt;             &quot;target&quot;: &quot;unstructured.data.concepts&quot;,&amp;lt;br&amp;gt;             &quot;condition&quot;: {&amp;lt;br&amp;gt;
   *           &quot;type&quot;: &quot;match&quot;,&amp;lt;br&amp;gt;                &quot;field&quot;: &quot;semanticType&quot;,&amp;lt;br&amp;gt;                &quot;values&quot;:
   * [&amp;lt;br&amp;gt;                   &quot;neop&quot;&amp;lt;br&amp;gt;                 ],&amp;lt;br&amp;gt;                &quot;not&quot;: false,&amp;lt;br&amp;gt;
   *               &quot;caseInsensitive&quot;: false,&amp;lt;br&amp;gt;                &quot;operator&quot;: &quot;equals&quot;&amp;lt;br&amp;gt;
   * }&amp;lt;br&amp;gt;            }&amp;lt;br&amp;gt;         }&amp;lt;br&amp;gt;       ]&amp;lt;br&amp;gt;    }&amp;lt;br&amp;gt;  ]&amp;lt;br&amp;gt;}&amp;lt;/pre&amp;gt;.
   *
   * @return a {@link ServiceCall} with a void result
   */
  public ServiceCall&lt;Void&gt; createProfile() {
<span class="nc" id="L281">    return createProfile(null);</span>
  }

  /**
   * Get details of a specific profile.
   *
   * Using the specified profile ID, retrieves the profile definition.
   *
   * @param getProfileOptions the {@link GetProfileOptions} containing the options for the call
   * @return a {@link ServiceCall} with a result of type {@link AcdProfile}
   */
  public ServiceCall&lt;AcdProfile&gt; getProfile(GetProfileOptions getProfileOptions) {
<span class="fc" id="L293">    com.ibm.cloud.sdk.core.util.Validator.notNull(getProfileOptions,</span>
      &quot;getProfileOptions cannot be null&quot;);
<span class="fc" id="L295">    String[] pathSegments = { &quot;v1/profiles&quot; };</span>
<span class="fc" id="L296">    String[] pathParameters = { getProfileOptions.id() };</span>
<span class="fc" id="L297">    RequestBuilder builder = RequestBuilder.get(RequestBuilder.constructHttpUrl(getServiceUrl(), pathSegments, pathParameters));</span>
<span class="fc" id="L298">    Map&lt;String, String&gt; sdkHeaders = SdkCommon.getSdkHeaders(&quot;annotator_for_clinical_data_acd&quot;, &quot;v1&quot;, &quot;getProfile&quot;);</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">    for (Entry&lt;String, String&gt; header : sdkHeaders.entrySet()) {</span>
<span class="fc" id="L300">      builder.header(header.getKey(), header.getValue());</span>
<span class="fc" id="L301">    }</span>
<span class="fc" id="L302">    builder.header(&quot;Accept&quot;, &quot;application/json&quot;);</span>
<span class="fc" id="L303">    builder.query(&quot;version&quot;, this.version);</span>
<span class="fc" id="L304">    ResponseConverter&lt;AcdProfile&gt; responseConverter =</span>
<span class="fc" id="L305">      ResponseConverterUtils.getValue(new com.google.gson.reflect.TypeToken&lt;AcdProfile&gt;() { }.getType());</span>
<span class="fc" id="L306">    return createServiceCall(builder.build(), responseConverter);</span>
  }

  /**
   * Update a persisted profile definition.
   *
   * Using the specified Profile ID, updates the profile definition.  This is a complete replacement of the existing
   * profile definition using the JSON object provided in the request body.
   *
   * @param updateProfileOptions the {@link UpdateProfileOptions} containing the options for the call
   * @return a {@link ServiceCall} with a void result
   */
  public ServiceCall&lt;Void&gt; updateProfile(UpdateProfileOptions updateProfileOptions) {
<span class="fc" id="L319">    com.ibm.cloud.sdk.core.util.Validator.notNull(updateProfileOptions,</span>
      &quot;updateProfileOptions cannot be null&quot;);
<span class="fc" id="L321">    String[] pathSegments = { &quot;v1/profiles&quot; };</span>
<span class="fc" id="L322">    String[] pathParameters = { updateProfileOptions.id() };</span>
<span class="fc" id="L323">    RequestBuilder builder = RequestBuilder.put(RequestBuilder.constructHttpUrl(getServiceUrl(), pathSegments, pathParameters));</span>
<span class="fc" id="L324">    Map&lt;String, String&gt; sdkHeaders = SdkCommon.getSdkHeaders(&quot;annotator_for_clinical_data_acd&quot;, &quot;v1&quot;, &quot;updateProfile&quot;);</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">    for (Entry&lt;String, String&gt; header : sdkHeaders.entrySet()) {</span>
<span class="fc" id="L326">      builder.header(header.getKey(), header.getValue());</span>
<span class="fc" id="L327">    }</span>
<span class="fc" id="L328">    builder.query(&quot;version&quot;, this.version);</span>
<span class="fc" id="L329">    final JsonObject contentJson = new JsonObject();</span>
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">    if (updateProfileOptions.newId() != null) {</span>
<span class="fc" id="L331">      contentJson.addProperty(&quot;id&quot;, updateProfileOptions.newId());</span>
    }
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">    if (updateProfileOptions.newName() != null) {</span>
<span class="fc" id="L334">      contentJson.addProperty(&quot;name&quot;, updateProfileOptions.newName());</span>
    }
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">    if (updateProfileOptions.newDescription() != null) {</span>
<span class="fc" id="L337">      contentJson.addProperty(&quot;description&quot;, updateProfileOptions.newDescription());</span>
    }
<span class="pc bpc" id="L339" title="1 of 2 branches missed.">    if (updateProfileOptions.newPublishedDate() != null) {</span>
<span class="fc" id="L340">      contentJson.addProperty(&quot;publishedDate&quot;, updateProfileOptions.newPublishedDate());</span>
    }
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">    if (updateProfileOptions.newPublish() != null) {</span>
<span class="fc" id="L343">      contentJson.addProperty(&quot;publish&quot;, updateProfileOptions.newPublish());</span>
    }
<span class="pc bpc" id="L345" title="1 of 2 branches missed.">    if (updateProfileOptions.newVersion() != null) {</span>
<span class="fc" id="L346">      contentJson.addProperty(&quot;version&quot;, updateProfileOptions.newVersion());</span>
    }
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">    if (updateProfileOptions.newCartridgeId() != null) {</span>
<span class="fc" id="L349">      contentJson.addProperty(&quot;cartridgeId&quot;, updateProfileOptions.newCartridgeId());</span>
    }
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">    if (updateProfileOptions.newAnnotators() != null) {</span>
<span class="fc" id="L352">      contentJson.add(&quot;annotators&quot;, com.ibm.cloud.sdk.core.util.GsonSingleton.getGson().toJsonTree(updateProfileOptions.newAnnotators()));</span>
    }
<span class="fc" id="L354">    builder.bodyJson(contentJson);</span>
<span class="fc" id="L355">    ResponseConverter&lt;Void&gt; responseConverter = ResponseConverterUtils.getVoid();</span>
<span class="fc" id="L356">    return createServiceCall(builder.build(), responseConverter);</span>
  }

  /**
   * Delete a persisted profile.
   *
   * Using the specified profile ID, deletes the profile from the list of persisted profiles.
   *
   * @param deleteProfileOptions the {@link DeleteProfileOptions} containing the options for the call
   * @return a {@link ServiceCall} with a void result
   */
  public ServiceCall&lt;Void&gt; deleteProfile(DeleteProfileOptions deleteProfileOptions) {
<span class="fc" id="L368">    com.ibm.cloud.sdk.core.util.Validator.notNull(deleteProfileOptions,</span>
      &quot;deleteProfileOptions cannot be null&quot;);
<span class="fc" id="L370">    String[] pathSegments = { &quot;v1/profiles&quot; };</span>
<span class="fc" id="L371">    String[] pathParameters = { deleteProfileOptions.id() };</span>
<span class="fc" id="L372">    RequestBuilder builder = RequestBuilder.delete(RequestBuilder.constructHttpUrl(getServiceUrl(), pathSegments, pathParameters));</span>
<span class="fc" id="L373">    Map&lt;String, String&gt; sdkHeaders = SdkCommon.getSdkHeaders(&quot;annotator_for_clinical_data_acd&quot;, &quot;v1&quot;, &quot;deleteProfile&quot;);</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">    for (Entry&lt;String, String&gt; header : sdkHeaders.entrySet()) {</span>
<span class="fc" id="L375">      builder.header(header.getKey(), header.getValue());</span>
<span class="fc" id="L376">    }</span>
<span class="fc" id="L377">    builder.query(&quot;version&quot;, this.version);</span>
<span class="fc" id="L378">    ResponseConverter&lt;Void&gt; responseConverter = ResponseConverterUtils.getVoid();</span>
<span class="fc" id="L379">    return createServiceCall(builder.build(), responseConverter);</span>
  }

  /**
   * Get list of available persisted flows.
   *
   * Returns a summary including ID and description of the available persisted flows.
   *
   * @param getFlowsOptions the {@link GetFlowsOptions} containing the options for the call
   * @return a {@link ServiceCall} with a result of type {@link ListStringWrapper}
   */
  public ServiceCall&lt;Map&lt;String, AcdFlow&gt;&gt; getFlows(GetFlowsOptions getFlowsOptions) {
<span class="fc" id="L391">    String[] pathSegments = { &quot;v1/flows&quot; };</span>
<span class="fc" id="L392">    RequestBuilder builder = RequestBuilder.get(RequestBuilder.constructHttpUrl(getServiceUrl(), pathSegments));</span>
<span class="fc" id="L393">    Map&lt;String, String&gt; sdkHeaders = SdkCommon.getSdkHeaders(&quot;annotator_for_clinical_data_acd&quot;, &quot;v1&quot;, &quot;getFlows&quot;);</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">    for (Entry&lt;String, String&gt; header : sdkHeaders.entrySet()) {</span>
<span class="fc" id="L395">      builder.header(header.getKey(), header.getValue());</span>
<span class="fc" id="L396">    }</span>
<span class="fc" id="L397">    builder.header(&quot;Accept&quot;, &quot;application/json&quot;);</span>
<span class="fc" id="L398">    builder.query(&quot;version&quot;, this.version);</span>
<span class="fc" id="L399">    ResponseConverter&lt;Map&lt;String, AcdFlow&gt;&gt; responseConverter =</span>
<span class="fc" id="L400">      ResponseConverterUtils.getValue(new com.google.gson.reflect.TypeToken&lt;Map&lt;String, AcdFlow&gt;&gt;() { }.getType());</span>
<span class="fc" id="L401">    return createServiceCall(builder.build(), responseConverter);</span>
  }

  /**
   * Get list of available persisted flows.
   *
   * Returns a summary including ID and description of the available persisted flows.
   *
   * @return a {@link ServiceCall} with a result of type {@link ListStringWrapper}
   */
  public ServiceCall&lt;Map&lt;String, AcdFlow&gt;&gt; getFlows() {
<span class="nc" id="L412">    return getFlows(null);</span>
  }

  /**
   * Persist a new flow definition.
   *
   * This API persists a new flow.  A flow is identified by an ID.  This ID can optionally be specified as part of the
   * request body when invoking &amp;lt;b&amp;gt;POST /v1/analyze&amp;lt;/b&amp;gt; API.  A flow definition contains a list one or more
   * annotators, and optionally can include annotator configuration, a flow ID, and/or flow sequence.&amp;lt;p&amp;gt;If a
   * caller would choose to have the ID of the new flow generated on their behalf, then in the request body the &quot;id&quot;
   * field of the flow definition should be an empty string (&quot;&quot;).  The auto-generated ID would be a normalized form of
   * the &quot;name&quot; field from the flow definition.&amp;lt;p&amp;gt;&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Sample Flow #1&amp;lt;/b&amp;gt;&amp;lt;br&amp;gt;A flow
   * definition that includes two annotators.&amp;lt;br&amp;gt;&amp;lt;pre&amp;gt;{&amp;lt;br&amp;gt;  &quot;id&quot;: &quot;flow_simple&quot;,&amp;lt;br&amp;gt;  &quot;name&quot;:
   * &quot;flow simple&quot;,&amp;lt;br&amp;gt;  &quot;description&quot;: &quot;A simple flow with two annotators&quot;,&amp;lt;br&amp;gt;  &quot;annotatorFlows&quot;:
   * [&amp;lt;br&amp;gt;      {&amp;lt;br&amp;gt;       &quot;flow&quot;: {&amp;lt;br&amp;gt;          &quot;elements&quot;: [&amp;lt;br&amp;gt;             {&amp;lt;br&amp;gt;
   *           &quot;annotator&quot;: {&amp;lt;br&amp;gt;                   &quot;name&quot;: &quot;concept_detection&quot;&amp;lt;br&amp;gt;
   * }&amp;lt;br&amp;gt;             },&amp;lt;br&amp;gt;             {&amp;lt;br&amp;gt;               &quot;annotator&quot;: {&amp;lt;br&amp;gt;
   *   &quot;name&quot;: &quot;symptom_disease&quot;&amp;lt;br&amp;gt;                }&amp;lt;br&amp;gt;             }&amp;lt;br&amp;gt;           ],&amp;lt;br&amp;gt;
   *   &quot;async&quot;: false&amp;lt;br&amp;gt;        }&amp;lt;br&amp;gt;      }&amp;lt;br&amp;gt;   ]&amp;lt;br&amp;gt;}&amp;lt;/pre&amp;gt;&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Sample
   * Flow #2&amp;lt;/b&amp;gt;&amp;lt;br&amp;gt;A flow definition that includes the 'concept_detection' annotator and configuration
   * details for the 'concept_detection' annotator.&amp;lt;br&amp;gt;&amp;lt;pre&amp;gt;{&amp;lt;br&amp;gt;  &quot;id&quot;:
   * &quot;flow_concept_detection_exclude_non_neop&quot;,&amp;lt;br&amp;gt;  &quot;name&quot;: &quot;flow concept detection exclude non neop&quot;,&amp;lt;br&amp;gt;
   * &quot;description&quot;: &quot;A flow excluding detected concepts that do not have 'neop' semantic type&quot;,&amp;lt;br&amp;gt;
   * &quot;annotatorFlows&quot;: [&amp;lt;br&amp;gt;      {&amp;lt;br&amp;gt;       &quot;flow&quot;: {&amp;lt;br&amp;gt;          &quot;elements&quot;: [&amp;lt;br&amp;gt;
   *   {&amp;lt;br&amp;gt;               &quot;annotator&quot;: {&amp;lt;br&amp;gt;                   &quot;name&quot;: &quot;concept_detection&quot;,&amp;lt;br&amp;gt;
   *             &quot;configurations&quot;: [&amp;lt;br&amp;gt;                      {&amp;lt;br&amp;gt;                        &quot;filter&quot;:
   * {&amp;lt;br&amp;gt;                           &quot;target&quot;: &quot;unstructured.data.concepts&quot;,&amp;lt;br&amp;gt;
   * &quot;condition&quot;: {&amp;lt;br&amp;gt;                              &quot;type&quot;: &quot;match&quot;,&amp;lt;br&amp;gt;
   * &quot;field&quot;: &quot;semanticType&quot;,&amp;lt;br&amp;gt;                              &quot;values&quot;: [&amp;lt;br&amp;gt;
   *   &quot;neop&quot;&amp;lt;br&amp;gt;                                ],&amp;lt;br&amp;gt;                              &quot;not&quot;: false,&amp;lt;br&amp;gt;
   *                              &quot;caseInsensitive&quot;: false,&amp;lt;br&amp;gt;                              &quot;operator&quot;:
   * &quot;equals&quot;&amp;lt;br&amp;gt;                            }&amp;lt;br&amp;gt;                         }&amp;lt;br&amp;gt;
   * }&amp;lt;br&amp;gt;                    ]&amp;lt;br&amp;gt;                 }&amp;lt;br&amp;gt;              }&amp;lt;br&amp;gt;
   * ],&amp;lt;br&amp;gt;       &quot;async&quot;: false&amp;lt;br&amp;gt;        }&amp;lt;br&amp;gt;      }&amp;lt;br&amp;gt;   ]&amp;lt;br&amp;gt;}&amp;lt;/pre&amp;gt;.
   *
   * @param createFlowsOptions the {@link CreateFlowsOptions} containing the options for the call
   * @return a {@link ServiceCall} with a void result
   */
  public ServiceCall&lt;Void&gt; createFlows(CreateFlowsOptions createFlowsOptions) {
<span class="fc" id="L451">    com.ibm.cloud.sdk.core.util.Validator.notNull(createFlowsOptions,</span>
      &quot;createFlowsOptions cannot be null&quot;);
<span class="fc" id="L453">    String[] pathSegments = { &quot;v1/flows&quot; };</span>
<span class="fc" id="L454">    RequestBuilder builder = RequestBuilder.post(RequestBuilder.constructHttpUrl(getServiceUrl(), pathSegments));</span>
<span class="fc" id="L455">    Map&lt;String, String&gt; sdkHeaders = SdkCommon.getSdkHeaders(&quot;annotator_for_clinical_data_acd&quot;, &quot;v1&quot;, &quot;createFlows&quot;);</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">    for (Entry&lt;String, String&gt; header : sdkHeaders.entrySet()) {</span>
<span class="fc" id="L457">      builder.header(header.getKey(), header.getValue());</span>
<span class="fc" id="L458">    }</span>
<span class="fc" id="L459">    builder.query(&quot;version&quot;, this.version);</span>
<span class="fc" id="L460">    final JsonObject contentJson = new JsonObject();</span>
<span class="pc bpc" id="L461" title="1 of 2 branches missed.">    if (createFlowsOptions.id() != null) {</span>
<span class="fc" id="L462">      contentJson.addProperty(&quot;id&quot;, createFlowsOptions.id());</span>
    }
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">    if (createFlowsOptions.name() != null) {</span>
<span class="fc" id="L465">      contentJson.addProperty(&quot;name&quot;, createFlowsOptions.name());</span>
    }
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">    if (createFlowsOptions.description() != null) {</span>
<span class="fc" id="L468">      contentJson.addProperty(&quot;description&quot;, createFlowsOptions.description());</span>
    }
<span class="pc bpc" id="L470" title="1 of 2 branches missed.">    if (createFlowsOptions.publishedDate() != null) {</span>
<span class="fc" id="L471">      contentJson.addProperty(&quot;publishedDate&quot;, createFlowsOptions.publishedDate());</span>
    }
<span class="pc bpc" id="L473" title="1 of 2 branches missed.">    if (createFlowsOptions.publish() != null) {</span>
<span class="fc" id="L474">      contentJson.addProperty(&quot;publish&quot;, createFlowsOptions.publish());</span>
    }
<span class="pc bpc" id="L476" title="1 of 2 branches missed.">    if (createFlowsOptions.version() != null) {</span>
<span class="fc" id="L477">      contentJson.addProperty(&quot;version&quot;, createFlowsOptions.version());</span>
    }
<span class="pc bpc" id="L479" title="1 of 2 branches missed.">    if (createFlowsOptions.cartridgeId() != null) {</span>
<span class="fc" id="L480">      contentJson.addProperty(&quot;cartridgeId&quot;, createFlowsOptions.cartridgeId());</span>
    }
<span class="pc bpc" id="L482" title="1 of 2 branches missed.">    if (createFlowsOptions.annotatorFlows() != null) {</span>
<span class="fc" id="L483">      contentJson.add(&quot;annotatorFlows&quot;, com.ibm.cloud.sdk.core.util.GsonSingleton.getGson().toJsonTree(createFlowsOptions.annotatorFlows()));</span>
    }
<span class="fc" id="L485">    builder.bodyJson(contentJson);</span>
<span class="fc" id="L486">    ResponseConverter&lt;Void&gt; responseConverter = ResponseConverterUtils.getVoid();</span>
<span class="fc" id="L487">    return createServiceCall(builder.build(), responseConverter);</span>
  }

  /**
   * Persist a new flow definition.
   *
   * This API persists a new flow.  A flow is identified by an ID.  This ID can optionally be specified as part of the
   * request body when invoking &amp;lt;b&amp;gt;POST /v1/analyze&amp;lt;/b&amp;gt; API.  A flow definition contains a list one or more
   * annotators, and optionally can include annotator configuration, a flow ID, and/or flow sequence.&amp;lt;p&amp;gt;If a
   * caller would choose to have the ID of the new flow generated on their behalf, then in the request body the &quot;id&quot;
   * field of the flow definition should be an empty string (&quot;&quot;).  The auto-generated ID would be a normalized form of
   * the &quot;name&quot; field from the flow definition.&amp;lt;p&amp;gt;&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Sample Flow #1&amp;lt;/b&amp;gt;&amp;lt;br&amp;gt;A flow
   * definition that includes two annotators.&amp;lt;br&amp;gt;&amp;lt;pre&amp;gt;{&amp;lt;br&amp;gt;  &quot;id&quot;: &quot;flow_simple&quot;,&amp;lt;br&amp;gt;  &quot;name&quot;:
   * &quot;flow simple&quot;,&amp;lt;br&amp;gt;  &quot;description&quot;: &quot;A simple flow with two annotators&quot;,&amp;lt;br&amp;gt;  &quot;annotatorFlows&quot;:
   * [&amp;lt;br&amp;gt;      {&amp;lt;br&amp;gt;       &quot;flow&quot;: {&amp;lt;br&amp;gt;          &quot;elements&quot;: [&amp;lt;br&amp;gt;             {&amp;lt;br&amp;gt;
   *           &quot;annotator&quot;: {&amp;lt;br&amp;gt;                   &quot;name&quot;: &quot;concept_detection&quot;&amp;lt;br&amp;gt;
   * }&amp;lt;br&amp;gt;             },&amp;lt;br&amp;gt;             {&amp;lt;br&amp;gt;               &quot;annotator&quot;: {&amp;lt;br&amp;gt;
   *   &quot;name&quot;: &quot;symptom_disease&quot;&amp;lt;br&amp;gt;                }&amp;lt;br&amp;gt;             }&amp;lt;br&amp;gt;           ],&amp;lt;br&amp;gt;
   *   &quot;async&quot;: false&amp;lt;br&amp;gt;        }&amp;lt;br&amp;gt;      }&amp;lt;br&amp;gt;   ]&amp;lt;br&amp;gt;}&amp;lt;/pre&amp;gt;&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Sample
   * Flow #2&amp;lt;/b&amp;gt;&amp;lt;br&amp;gt;A flow definition that includes the 'concept_detection' annotator and configuration
   * details for the 'concept_detection' annotator.&amp;lt;br&amp;gt;&amp;lt;pre&amp;gt;{&amp;lt;br&amp;gt;  &quot;id&quot;:
   * &quot;flow_concept_detection_exclude_non_neop&quot;,&amp;lt;br&amp;gt;  &quot;name&quot;: &quot;flow concept detection exclude non neop&quot;,&amp;lt;br&amp;gt;
   * &quot;description&quot;: &quot;A flow excluding detected concepts that do not have 'neop' semantic type&quot;,&amp;lt;br&amp;gt;
   * &quot;annotatorFlows&quot;: [&amp;lt;br&amp;gt;      {&amp;lt;br&amp;gt;       &quot;flow&quot;: {&amp;lt;br&amp;gt;          &quot;elements&quot;: [&amp;lt;br&amp;gt;
   *   {&amp;lt;br&amp;gt;               &quot;annotator&quot;: {&amp;lt;br&amp;gt;                   &quot;name&quot;: &quot;concept_detection&quot;,&amp;lt;br&amp;gt;
   *             &quot;configurations&quot;: [&amp;lt;br&amp;gt;                      {&amp;lt;br&amp;gt;                        &quot;filter&quot;:
   * {&amp;lt;br&amp;gt;                           &quot;target&quot;: &quot;unstructured.data.concepts&quot;,&amp;lt;br&amp;gt;
   * &quot;condition&quot;: {&amp;lt;br&amp;gt;                              &quot;type&quot;: &quot;match&quot;,&amp;lt;br&amp;gt;
   * &quot;field&quot;: &quot;semanticType&quot;,&amp;lt;br&amp;gt;                              &quot;values&quot;: [&amp;lt;br&amp;gt;
   *   &quot;neop&quot;&amp;lt;br&amp;gt;                                ],&amp;lt;br&amp;gt;                              &quot;not&quot;: false,&amp;lt;br&amp;gt;
   *                              &quot;caseInsensitive&quot;: false,&amp;lt;br&amp;gt;                              &quot;operator&quot;:
   * &quot;equals&quot;&amp;lt;br&amp;gt;                            }&amp;lt;br&amp;gt;                         }&amp;lt;br&amp;gt;
   * }&amp;lt;br&amp;gt;                    ]&amp;lt;br&amp;gt;                 }&amp;lt;br&amp;gt;              }&amp;lt;br&amp;gt;
   * ],&amp;lt;br&amp;gt;       &quot;async&quot;: false&amp;lt;br&amp;gt;        }&amp;lt;br&amp;gt;      }&amp;lt;br&amp;gt;   ]&amp;lt;br&amp;gt;}&amp;lt;/pre&amp;gt;.
   *
   * @return a {@link ServiceCall} with a void result
   */
  public ServiceCall&lt;Void&gt; createFlows() {
<span class="nc" id="L525">    return createFlows(null);</span>
  }

  /**
   * Get details of a specific flow.
   *
   * Using the specified Flow ID, retrieves the flow definition.
   *
   * @param getFlowsByIdOptions the {@link GetFlowsByIdOptions} containing the options for the call
   * @return a {@link ServiceCall} with a result of type {@link AcdFlow}
   */
  public ServiceCall&lt;AcdFlow&gt; getFlowsById(GetFlowsByIdOptions getFlowsByIdOptions) {
<span class="fc" id="L537">    com.ibm.cloud.sdk.core.util.Validator.notNull(getFlowsByIdOptions,</span>
      &quot;getFlowsByIdOptions cannot be null&quot;);
<span class="fc" id="L539">    String[] pathSegments = { &quot;v1/flows&quot; };</span>
<span class="fc" id="L540">    String[] pathParameters = { getFlowsByIdOptions.id() };</span>
<span class="fc" id="L541">    RequestBuilder builder = RequestBuilder.get(RequestBuilder.constructHttpUrl(getServiceUrl(), pathSegments, pathParameters));</span>
<span class="fc" id="L542">    Map&lt;String, String&gt; sdkHeaders = SdkCommon.getSdkHeaders(&quot;annotator_for_clinical_data_acd&quot;, &quot;v1&quot;, &quot;getFlowsById&quot;);</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">    for (Entry&lt;String, String&gt; header : sdkHeaders.entrySet()) {</span>
<span class="fc" id="L544">      builder.header(header.getKey(), header.getValue());</span>
<span class="fc" id="L545">    }</span>
<span class="fc" id="L546">    builder.header(&quot;Accept&quot;, &quot;application/json&quot;);</span>
<span class="fc" id="L547">    builder.query(&quot;version&quot;, this.version);</span>
<span class="fc" id="L548">    ResponseConverter&lt;AcdFlow&gt; responseConverter =</span>
<span class="fc" id="L549">      ResponseConverterUtils.getValue(new com.google.gson.reflect.TypeToken&lt;AcdFlow&gt;() { }.getType());</span>
<span class="fc" id="L550">    return createServiceCall(builder.build(), responseConverter);</span>
  }

  /**
   * Update a persisted flow definition.
   *
   * Using the specified Flow ID, updates the persisted flow definition.  This is a complete replacement of the existing
   * flow definition using the JSON object provided in the request body.
   *
   * @param updateFlowsOptions the {@link UpdateFlowsOptions} containing the options for the call
   * @return a {@link ServiceCall} with a void result
   */
  public ServiceCall&lt;Void&gt; updateFlows(UpdateFlowsOptions updateFlowsOptions) {
<span class="fc" id="L563">    com.ibm.cloud.sdk.core.util.Validator.notNull(updateFlowsOptions,</span>
      &quot;updateFlowsOptions cannot be null&quot;);
<span class="fc" id="L565">    String[] pathSegments = { &quot;v1/flows&quot; };</span>
<span class="fc" id="L566">    String[] pathParameters = { updateFlowsOptions.id() };</span>
<span class="fc" id="L567">    RequestBuilder builder = RequestBuilder.put(RequestBuilder.constructHttpUrl(getServiceUrl(), pathSegments, pathParameters));</span>
<span class="fc" id="L568">    Map&lt;String, String&gt; sdkHeaders = SdkCommon.getSdkHeaders(&quot;annotator_for_clinical_data_acd&quot;, &quot;v1&quot;, &quot;updateFlows&quot;);</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">    for (Entry&lt;String, String&gt; header : sdkHeaders.entrySet()) {</span>
<span class="fc" id="L570">      builder.header(header.getKey(), header.getValue());</span>
<span class="fc" id="L571">    }</span>
<span class="fc" id="L572">    builder.query(&quot;version&quot;, this.version);</span>
<span class="fc" id="L573">    final JsonObject contentJson = new JsonObject();</span>
<span class="pc bpc" id="L574" title="1 of 2 branches missed.">    if (updateFlowsOptions.newId() != null) {</span>
<span class="fc" id="L575">      contentJson.addProperty(&quot;id&quot;, updateFlowsOptions.newId());</span>
    }
<span class="pc bpc" id="L577" title="1 of 2 branches missed.">    if (updateFlowsOptions.newName() != null) {</span>
<span class="fc" id="L578">      contentJson.addProperty(&quot;name&quot;, updateFlowsOptions.newName());</span>
    }
<span class="pc bpc" id="L580" title="1 of 2 branches missed.">    if (updateFlowsOptions.newDescription() != null) {</span>
<span class="fc" id="L581">      contentJson.addProperty(&quot;description&quot;, updateFlowsOptions.newDescription());</span>
    }
<span class="pc bpc" id="L583" title="1 of 2 branches missed.">    if (updateFlowsOptions.newPublishedDate() != null) {</span>
<span class="fc" id="L584">      contentJson.addProperty(&quot;publishedDate&quot;, updateFlowsOptions.newPublishedDate());</span>
    }
<span class="pc bpc" id="L586" title="1 of 2 branches missed.">    if (updateFlowsOptions.newPublish() != null) {</span>
<span class="fc" id="L587">      contentJson.addProperty(&quot;publish&quot;, updateFlowsOptions.newPublish());</span>
    }
<span class="pc bpc" id="L589" title="1 of 2 branches missed.">    if (updateFlowsOptions.newVersion() != null) {</span>
<span class="fc" id="L590">      contentJson.addProperty(&quot;version&quot;, updateFlowsOptions.newVersion());</span>
    }
<span class="pc bpc" id="L592" title="1 of 2 branches missed.">    if (updateFlowsOptions.newCartridgeId() != null) {</span>
<span class="fc" id="L593">      contentJson.addProperty(&quot;cartridgeId&quot;, updateFlowsOptions.newCartridgeId());</span>
    }
<span class="pc bpc" id="L595" title="1 of 2 branches missed.">    if (updateFlowsOptions.newAnnotatorFlows() != null) {</span>
<span class="fc" id="L596">      contentJson.add(&quot;annotatorFlows&quot;, com.ibm.cloud.sdk.core.util.GsonSingleton.getGson().toJsonTree(updateFlowsOptions.newAnnotatorFlows()));</span>
    }
<span class="fc" id="L598">    builder.bodyJson(contentJson);</span>
<span class="fc" id="L599">    ResponseConverter&lt;Void&gt; responseConverter = ResponseConverterUtils.getVoid();</span>
<span class="fc" id="L600">    return createServiceCall(builder.build(), responseConverter);</span>
  }

  /**
   * Delete a persisted flow.
   *
   * Using the specified Flow ID, deletes the flow from the list of persisted flows.
   *
   * @param deleteFlowsOptions the {@link DeleteFlowsOptions} containing the options for the call
   * @return a {@link ServiceCall} with a void result
   */
  public ServiceCall&lt;Void&gt; deleteFlows(DeleteFlowsOptions deleteFlowsOptions) {
<span class="fc" id="L612">    com.ibm.cloud.sdk.core.util.Validator.notNull(deleteFlowsOptions,</span>
      &quot;deleteFlowsOptions cannot be null&quot;);
<span class="fc" id="L614">    String[] pathSegments = { &quot;v1/flows&quot; };</span>
<span class="fc" id="L615">    String[] pathParameters = { deleteFlowsOptions.id() };</span>
<span class="fc" id="L616">    RequestBuilder builder = RequestBuilder.delete(RequestBuilder.constructHttpUrl(getServiceUrl(), pathSegments, pathParameters));</span>
<span class="fc" id="L617">    Map&lt;String, String&gt; sdkHeaders = SdkCommon.getSdkHeaders(&quot;annotator_for_clinical_data_acd&quot;, &quot;v1&quot;, &quot;deleteFlows&quot;);</span>
<span class="fc bfc" id="L618" title="All 2 branches covered.">    for (Entry&lt;String, String&gt; header : sdkHeaders.entrySet()) {</span>
<span class="fc" id="L619">      builder.header(header.getKey(), header.getValue());</span>
<span class="fc" id="L620">    }</span>
<span class="fc" id="L621">    builder.query(&quot;version&quot;, this.version);</span>
<span class="fc" id="L622">    ResponseConverter&lt;Void&gt; responseConverter = ResponseConverterUtils.getVoid();</span>
<span class="fc" id="L623">    return createServiceCall(builder.build(), responseConverter);</span>
  }

  /**
   * Detect entities &amp;amp; relations from unstructured data.
   *
   * &amp;lt;p&amp;gt;This API accepts a JSON request model featuring both the unstructured data to be analyzed as well as the
   * desired annotator flow.&amp;lt;p/&amp;gt;&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Annotator Chaining&amp;lt;/b&amp;gt;&amp;lt;br/&amp;gt;Sample request invoking
   * both the concept_detection and symptom_disease annotators asynchronously. This sample request references
   * configurations via a profile id. Profiles define configurations that can be referenced within a request. Profile is
   * optional. A default profile is used if no profile id is available in the annotator flow. The default profile
   * contains the parameters for the concept detection and the attribute detection. An empty profile can be used if
   * absolutely no parameters are attached to any annotators. See &amp;lt;a href=&quot;..&quot;
   * target=&quot;_blank&quot;&amp;gt;documentation&amp;lt;/a&amp;gt; for more information. &amp;lt;/p&amp;gt;&amp;lt;pre&amp;gt;{&amp;lt;br/&amp;gt;
   * &quot;annotatorFlows&quot;: [&amp;lt;br/&amp;gt;    {&amp;lt;br/&amp;gt;      &quot;profile&quot; : &quot;default_profile_v1.0&quot;, &amp;lt;br/&amp;gt;      &quot;flow&quot;:
   * {&amp;lt;br/&amp;gt;        &quot;elements&quot;: [&amp;lt;br/&amp;gt;          {&amp;lt;br/&amp;gt;            &quot;annotator&quot;: {&amp;lt;br/&amp;gt;
   *  &quot;name&quot;: &quot;concept_detection&quot;&amp;lt;br/&amp;gt;            }&amp;lt;br/&amp;gt;          },&amp;lt;br/&amp;gt;          {&amp;lt;br/&amp;gt;
   *     &quot;annotator&quot;: {&amp;lt;br/&amp;gt;              &quot;name&quot;: &quot;symptom_disease&quot;&amp;lt;br/&amp;gt;             }&amp;lt;br/&amp;gt;
   * }&amp;lt;br/&amp;gt;        ],&amp;lt;br/&amp;gt;        &quot;async&quot;: false&amp;lt;br/&amp;gt;      }&amp;lt;br/&amp;gt;    }&amp;lt;br/&amp;gt;  ],&amp;lt;br/&amp;gt;
   *  &quot;unstructured&quot;: [&amp;lt;br/&amp;gt;    {&amp;lt;br/&amp;gt;      &quot;text&quot;: &quot;Patient has lung cancer, but did not smoke. She may
   * consider chemotherapy as part of a treatment plan.&quot;&amp;lt;br/&amp;gt;    }&amp;lt;br/&amp;gt;
   * ]&amp;lt;br/&amp;gt;}&amp;lt;br/&amp;gt;&amp;lt;/pre&amp;gt;&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Annotation Filtering&amp;lt;/b&amp;gt;&amp;lt;br/&amp;gt;Sample request
   * invoking concept_detection with a filter defined to exclude any annotations detected from concept_detection where
   * the semanticType field does not equal &quot;neop&quot;.&amp;lt;/p&amp;gt;&amp;lt;pre&amp;gt;{&amp;lt;br/&amp;gt;  &quot;annotatorFlows&quot;: [&amp;lt;br/&amp;gt;
   * {&amp;lt;br/&amp;gt;      &quot;flow&quot;: {&amp;lt;br/&amp;gt;        &quot;elements&quot;: [&amp;lt;br/&amp;gt;          {&amp;lt;br/&amp;gt;
   * &quot;annotator&quot;: {&amp;lt;br/&amp;gt;              &quot;name&quot;: &quot;concept_detection&quot;,&amp;lt;br/&amp;gt;              &quot;configurations&quot;:
   * [&amp;lt;br/&amp;gt;                {&amp;lt;br/&amp;gt;                  &quot;filter&quot;: {&amp;lt;br/&amp;gt;                     &quot;target&quot;:
   * &quot;unstructured.data.concepts&quot;,&amp;lt;br/&amp;gt;                     &quot;condition&quot;: {&amp;lt;br/&amp;gt;
   * &quot;type&quot;: &quot;match&quot;,&amp;lt;br/&amp;gt;                        &quot;field&quot;: &quot;semanticType&quot;,&amp;lt;br/&amp;gt;
   * &quot;values&quot;: [&amp;lt;br/&amp;gt;                           &quot;neop&quot;&amp;lt;br/&amp;gt;                         ],&amp;lt;br/&amp;gt;
   *             &quot;not&quot;: false,&amp;lt;br/&amp;gt;                        &quot;caseInsensitive&quot;: false,&amp;lt;br/&amp;gt;
   *     &quot;operator&quot;: &quot;equals&quot;&amp;lt;br/&amp;gt;                     }&amp;lt;br/&amp;gt;                  }&amp;lt;br/&amp;gt;
   * }&amp;lt;br/&amp;gt;              ]&amp;lt;br/&amp;gt;            }&amp;lt;br/&amp;gt;          }&amp;lt;br/&amp;gt;        ],&amp;lt;br/&amp;gt;
   * &quot;async&quot;: false&amp;lt;br/&amp;gt;      }&amp;lt;br/&amp;gt;    }&amp;lt;br/&amp;gt;  ],&amp;lt;br/&amp;gt;  &quot;unstructured&quot;: [&amp;lt;br/&amp;gt;
   * {&amp;lt;br/&amp;gt;      &quot;text&quot;: &quot;Patient has lung cancer, but did not smoke. She may consider chemotherapy as part of a
   * treatment plan.&quot;&amp;lt;br/&amp;gt;    }&amp;lt;br/&amp;gt;  ]&amp;lt;br/&amp;gt;}&amp;lt;br/&amp;gt;&amp;lt;/pre&amp;gt;&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Annotators that
   * support annotation filtering:&amp;lt;/b&amp;gt; allergy, bathing_assistance, cancer, concept_detection,
   * dressing_assistance, eating_assistance, ejection_fraction, lab_value, medication, named_entities, procedure,
   * seeing_assistance, smoking, symptom_disease, toileting_assistance,
   * walking_assistance.&amp;lt;/p&amp;gt;&amp;lt;hr/&amp;gt;&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Annotation Augmentation&amp;lt;/b&amp;gt;&amp;lt;br/&amp;gt;Sample
   * request invoking the cancer annotator and providing a whitelist entry for a new custom surface form:
   * &quot;lungcancer&quot;.&amp;lt;/p&amp;gt;&amp;lt;pre&amp;gt;{&amp;lt;br/&amp;gt; &quot;annotatorFlows&quot;: [&amp;lt;br/&amp;gt;    {&amp;lt;br/&amp;gt;     &quot;flow&quot;:
   * {&amp;lt;br/&amp;gt;       &quot;elements&quot;: [&amp;lt;br/&amp;gt;          {&amp;lt;br/&amp;gt;           &quot;annotator&quot;: {&amp;lt;br/&amp;gt;
   * &quot;name&quot;: &quot;cancer&quot;,&amp;lt;br/&amp;gt;             &quot;configurations&quot;: [&amp;lt;br/&amp;gt;                {&amp;lt;br/&amp;gt;
   * &quot;whitelist&quot;: {&amp;lt;br/&amp;gt;                   &quot;name&quot;: &quot;cancer&quot;,&amp;lt;br/&amp;gt;                   &quot;entries&quot;: [&amp;lt;br/&amp;gt;
   *                     {&amp;lt;br/&amp;gt;                  &quot;surfaceForms&quot;: [&amp;lt;br/&amp;gt;
   * &quot;lungcancer&quot;&amp;lt;br/&amp;gt;                ],&amp;lt;br/&amp;gt;               &quot;features&quot;: {&amp;lt;br/&amp;gt;
   * &quot;normalizedName&quot;: &quot;lung cancer&quot;,&amp;lt;br/&amp;gt;                   &quot;hccCode&quot;: &quot;9&quot;,&amp;lt;br/&amp;gt;
   * &quot;icd10Code&quot;: &quot;C34.9&quot;,&amp;lt;br/&amp;gt;                   &quot;ccsCode&quot;: &quot;19&quot;,&amp;lt;br/&amp;gt;                   &quot;icd9Code&quot;:
   * &quot;162.9&quot;,&amp;lt;br/&amp;gt;                   &quot;conceptId&quot;: &quot;93880001&quot;&amp;lt;br/&amp;gt;                }&amp;lt;br/&amp;gt;
   *       }&amp;lt;br/&amp;gt;                    ]&amp;lt;br/&amp;gt;                  }&amp;lt;br/&amp;gt;                }&amp;lt;br/&amp;gt;
   *       ]&amp;lt;br/&amp;gt;            }&amp;lt;br/&amp;gt;          }&amp;lt;br/&amp;gt;        ],&amp;lt;br/&amp;gt;       &quot;async&quot;:
   * false&amp;lt;br/&amp;gt;      }&amp;lt;br/&amp;gt;    }&amp;lt;br/&amp;gt;  ],&amp;lt;br/&amp;gt; &quot;unstructured&quot;: [&amp;lt;br/&amp;gt;    {&amp;lt;br/&amp;gt;
   * &quot;text&quot;: &quot;The patient was diagnosed with lungcancer, on Dec 23, 2011.&quot;&amp;lt;br/&amp;gt;    }&amp;lt;br/&amp;gt;
   * ]&amp;lt;br/&amp;gt;}&amp;lt;br/&amp;gt;&amp;lt;/pre&amp;gt;&amp;lt;b&amp;gt;Annotators that support annotation augmentation:&amp;lt;/b&amp;gt; allergy,
   * bathing_assistance, cancer, dressing_assistance, eating_assistance, ejection_fraction, lab_value, medication,
   * named_entities, procedure, seeing_assistance, smoking, symptom_disease, toileting_assistance,
   * walking_assistance.&amp;lt;br/&amp;gt;.
   *
   * @param runPipelineOptions the {@link RunPipelineOptions} containing the options for the call
   * @return a {@link ServiceCall} with a void result
   */
  public ServiceCall&lt;Void&gt; runPipeline(RunPipelineOptions runPipelineOptions) {
<span class="fc" id="L686">    com.ibm.cloud.sdk.core.util.Validator.notNull(runPipelineOptions,</span>
      &quot;runPipelineOptions cannot be null&quot;);
<span class="fc" id="L688">    String[] pathSegments = { &quot;v1/analyze&quot; };</span>
<span class="fc" id="L689">    RequestBuilder builder = RequestBuilder.post(RequestBuilder.constructHttpUrl(getServiceUrl(), pathSegments));</span>
<span class="fc" id="L690">    Map&lt;String, String&gt; sdkHeaders = SdkCommon.getSdkHeaders(&quot;annotator_for_clinical_data_acd&quot;, &quot;v1&quot;, &quot;runPipeline&quot;);</span>
<span class="fc bfc" id="L691" title="All 2 branches covered.">    for (Entry&lt;String, String&gt; header : sdkHeaders.entrySet()) {</span>
<span class="fc" id="L692">      builder.header(header.getKey(), header.getValue());</span>
<span class="fc" id="L693">    }</span>
<span class="fc" id="L694">    builder.query(&quot;version&quot;, this.version);</span>
<span class="pc bpc" id="L695" title="1 of 2 branches missed.">    if (runPipelineOptions.debugTextRestore() != null) {</span>
<span class="fc" id="L696">      builder.query(&quot;debug_text_restore&quot;, String.valueOf(runPipelineOptions.debugTextRestore()));</span>
    }
<span class="pc bpc" id="L698" title="1 of 2 branches missed.">    if (runPipelineOptions.returnAnalyzedText() != null) {</span>
<span class="fc" id="L699">      builder.query(&quot;return_analyzed_text&quot;, String.valueOf(runPipelineOptions.returnAnalyzedText()));</span>
    }
<span class="fc" id="L701">    final JsonObject contentJson = new JsonObject();</span>
<span class="pc bpc" id="L702" title="1 of 2 branches missed.">    if (runPipelineOptions.unstructured() != null) {</span>
<span class="fc" id="L703">      contentJson.add(&quot;unstructured&quot;, com.ibm.cloud.sdk.core.util.GsonSingleton.getGson().toJsonTree(runPipelineOptions.unstructured()));</span>
    }
<span class="pc bpc" id="L705" title="1 of 2 branches missed.">    if (runPipelineOptions.annotatorFlows() != null) {</span>
<span class="fc" id="L706">      contentJson.add(&quot;annotatorFlows&quot;, com.ibm.cloud.sdk.core.util.GsonSingleton.getGson().toJsonTree(runPipelineOptions.annotatorFlows()));</span>
    }
<span class="fc" id="L708">    builder.bodyJson(contentJson);</span>
<span class="fc" id="L709">    ResponseConverter&lt;Void&gt; responseConverter = ResponseConverterUtils.getVoid();</span>
<span class="fc" id="L710">    return createServiceCall(builder.build(), responseConverter);</span>
  }

  /**
   * Detect entities and relations from unstructured data.
   *
   * &amp;lt;p&amp;gt;This API accepts a JSON request model featuring both the unstructured data to be analyzed as well as the
   * desired annotator flow.&amp;lt;p/&amp;gt;&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Annotator Chaining&amp;lt;/b&amp;gt;&amp;lt;br/&amp;gt;Sample request invoking
   * both the concept_detection and symptom_disease annotators asynchronously. This sample request references
   * configurations via a profile id. Profiles define configurations that can be referenced within a request. Profile is
   * optional. A default profile is used if no profile id is available in the annotator flow. The default profile
   * contains the parameters for the concept detection and the attribute detection. An empty profile can be used if
   * absolutely no parameters are attached to any annotators. See &amp;lt;a href=&quot;..&quot;
   * target=&quot;_blank&quot;&amp;gt;documentation&amp;lt;/a&amp;gt; for more information. &amp;lt;/p&amp;gt;&amp;lt;pre&amp;gt;{&amp;lt;br/&amp;gt;
   * &quot;annotatorFlows&quot;: [&amp;lt;br/&amp;gt;    {&amp;lt;br/&amp;gt;      &quot;profile&quot; : &quot;default_profile_v1.0&quot;, &amp;lt;br/&amp;gt;      &quot;flow&quot;:
   * {&amp;lt;br/&amp;gt;        &quot;elements&quot;: [&amp;lt;br/&amp;gt;          {&amp;lt;br/&amp;gt;            &quot;annotator&quot;: {&amp;lt;br/&amp;gt;
   *  &quot;name&quot;: &quot;concept_detection&quot;&amp;lt;br/&amp;gt;            }&amp;lt;br/&amp;gt;          },&amp;lt;br/&amp;gt;          {&amp;lt;br/&amp;gt;
   *     &quot;annotator&quot;: {&amp;lt;br/&amp;gt;              &quot;name&quot;: &quot;symptom_disease&quot;&amp;lt;br/&amp;gt;             }&amp;lt;br/&amp;gt;
   * }&amp;lt;br/&amp;gt;        ],&amp;lt;br/&amp;gt;        &quot;async&quot;: false&amp;lt;br/&amp;gt;      }&amp;lt;br/&amp;gt;    }&amp;lt;br/&amp;gt;  ],&amp;lt;br/&amp;gt;
   *  &quot;unstructured&quot;: [&amp;lt;br/&amp;gt;    {&amp;lt;br/&amp;gt;      &quot;text&quot;: &quot;Patient has lung cancer, but did not smoke. She may
   * consider chemotherapy as part of a treatment plan.&quot;&amp;lt;br/&amp;gt;    }&amp;lt;br/&amp;gt;
   * ]&amp;lt;br/&amp;gt;}&amp;lt;br/&amp;gt;&amp;lt;/pre&amp;gt;&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Annotation Filtering&amp;lt;/b&amp;gt;&amp;lt;br/&amp;gt;Sample request
   * invoking concept_detection with a filter defined to exclude any annotations detected from concept_detection where
   * the semanticType field does not equal &quot;neop&quot;.&amp;lt;/p&amp;gt;&amp;lt;pre&amp;gt;{&amp;lt;br/&amp;gt;  &quot;annotatorFlows&quot;: [&amp;lt;br/&amp;gt;
   * {&amp;lt;br/&amp;gt;      &quot;flow&quot;: {&amp;lt;br/&amp;gt;        &quot;elements&quot;: [&amp;lt;br/&amp;gt;          {&amp;lt;br/&amp;gt;
   * &quot;annotator&quot;: {&amp;lt;br/&amp;gt;              &quot;name&quot;: &quot;concept_detection&quot;,&amp;lt;br/&amp;gt;              &quot;configurations&quot;:
   * [&amp;lt;br/&amp;gt;                {&amp;lt;br/&amp;gt;                  &quot;filter&quot;: {&amp;lt;br/&amp;gt;                     &quot;target&quot;:
   * &quot;unstructured.data.concepts&quot;,&amp;lt;br/&amp;gt;                     &quot;condition&quot;: {&amp;lt;br/&amp;gt;
   * &quot;type&quot;: &quot;match&quot;,&amp;lt;br/&amp;gt;                        &quot;field&quot;: &quot;semanticType&quot;,&amp;lt;br/&amp;gt;
   * &quot;values&quot;: [&amp;lt;br/&amp;gt;                           &quot;neop&quot;&amp;lt;br/&amp;gt;                         ],&amp;lt;br/&amp;gt;
   *             &quot;not&quot;: false,&amp;lt;br/&amp;gt;                        &quot;caseInsensitive&quot;: false,&amp;lt;br/&amp;gt;
   *     &quot;operator&quot;: &quot;equals&quot;&amp;lt;br/&amp;gt;                     }&amp;lt;br/&amp;gt;                  }&amp;lt;br/&amp;gt;
   * }&amp;lt;br/&amp;gt;              ]&amp;lt;br/&amp;gt;            }&amp;lt;br/&amp;gt;          }&amp;lt;br/&amp;gt;        ],&amp;lt;br/&amp;gt;
   * &quot;async&quot;: false&amp;lt;br/&amp;gt;      }&amp;lt;br/&amp;gt;    }&amp;lt;br/&amp;gt;  ],&amp;lt;br/&amp;gt;  &quot;unstructured&quot;: [&amp;lt;br/&amp;gt;
   * {&amp;lt;br/&amp;gt;      &quot;text&quot;: &quot;Patient has lung cancer, but did not smoke. She may consider chemotherapy as part of a
   * treatment plan.&quot;&amp;lt;br/&amp;gt;    }&amp;lt;br/&amp;gt;  ]&amp;lt;br/&amp;gt;}&amp;lt;br/&amp;gt;&amp;lt;/pre&amp;gt;&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Annotators that
   * support annotation filtering:&amp;lt;/b&amp;gt; allergy, bathing_assistance, cancer, concept_detection,
   * dressing_assistance, eating_assistance, ejection_fraction, lab_value, medication, named_entities, procedure,
   * seeing_assistance, smoking, symptom_disease, toileting_assistance,
   * walking_assistance.&amp;lt;/p&amp;gt;&amp;lt;hr/&amp;gt;&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Annotation Augmentation&amp;lt;/b&amp;gt;&amp;lt;br/&amp;gt;Sample
   * request invoking the cancer annotator and providing a whitelist entry for a new custom surface form:
   * &quot;lungcancer&quot;.&amp;lt;/p&amp;gt;&amp;lt;pre&amp;gt;{&amp;lt;br/&amp;gt; &quot;annotatorFlows&quot;: [&amp;lt;br/&amp;gt;    {&amp;lt;br/&amp;gt;     &quot;flow&quot;:
   * {&amp;lt;br/&amp;gt;       &quot;elements&quot;: [&amp;lt;br/&amp;gt;          {&amp;lt;br/&amp;gt;           &quot;annotator&quot;: {&amp;lt;br/&amp;gt;
   * &quot;name&quot;: &quot;cancer&quot;,&amp;lt;br/&amp;gt;             &quot;configurations&quot;: [&amp;lt;br/&amp;gt;                {&amp;lt;br/&amp;gt;
   * &quot;whitelist&quot;: {&amp;lt;br/&amp;gt;                   &quot;name&quot;: &quot;cancer&quot;,&amp;lt;br/&amp;gt;                   &quot;entries&quot;: [&amp;lt;br/&amp;gt;
   *                     {&amp;lt;br/&amp;gt;                  &quot;surfaceForms&quot;: [&amp;lt;br/&amp;gt;
   * &quot;lungcancer&quot;&amp;lt;br/&amp;gt;                ],&amp;lt;br/&amp;gt;               &quot;features&quot;: {&amp;lt;br/&amp;gt;
   * &quot;normalizedName&quot;: &quot;lung cancer&quot;,&amp;lt;br/&amp;gt;                   &quot;hccCode&quot;: &quot;9&quot;,&amp;lt;br/&amp;gt;
   * &quot;icd10Code&quot;: &quot;C34.9&quot;,&amp;lt;br/&amp;gt;                   &quot;ccsCode&quot;: &quot;19&quot;,&amp;lt;br/&amp;gt;                   &quot;icd9Code&quot;:
   * &quot;162.9&quot;,&amp;lt;br/&amp;gt;                   &quot;conceptId&quot;: &quot;93880001&quot;&amp;lt;br/&amp;gt;                }&amp;lt;br/&amp;gt;
   *       }&amp;lt;br/&amp;gt;                    ]&amp;lt;br/&amp;gt;                  }&amp;lt;br/&amp;gt;                }&amp;lt;br/&amp;gt;
   *       ]&amp;lt;br/&amp;gt;            }&amp;lt;br/&amp;gt;          }&amp;lt;br/&amp;gt;        ],&amp;lt;br/&amp;gt;       &quot;async&quot;:
   * false&amp;lt;br/&amp;gt;      }&amp;lt;br/&amp;gt;    }&amp;lt;br/&amp;gt;  ],&amp;lt;br/&amp;gt; &quot;unstructured&quot;: [&amp;lt;br/&amp;gt;    {&amp;lt;br/&amp;gt;
   * &quot;text&quot;: &quot;The patient was diagnosed with lungcancer, on Dec 23, 2011.&quot;&amp;lt;br/&amp;gt;    }&amp;lt;br/&amp;gt;
   * ]&amp;lt;br/&amp;gt;}&amp;lt;br/&amp;gt;&amp;lt;/pre&amp;gt;&amp;lt;b&amp;gt;Annotators that support annotation augmentation:&amp;lt;/b&amp;gt; allergy,
   * bathing_assistance, cancer, dressing_assistance, eating_assistance, ejection_fraction, lab_value, medication,
   * named_entities, procedure, seeing_assistance, smoking, symptom_disease, toileting_assistance,
   * walking_assistance.&amp;lt;br/&amp;gt;.
   *
   * @return a {@link ServiceCall} with a void result
   */
  public ServiceCall&lt;Void&gt; runPipeline() {
<span class="nc" id="L772">    return runPipeline(null);</span>
  }

  /**
   * analyze with a pre-specified flow.
   *
   * &amp;lt;p&amp;gt;This API accepts a flow identifier as well as a &amp;lt;emph&amp;gt;TEXT&amp;lt;/emph&amp;gt; or a
   * &amp;lt;emph&amp;gt;JSON&amp;lt;/emph&amp;gt; request model featuring the unstructured text to be analyzed.
   * &amp;lt;p/&amp;gt;&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;JSON request model with unstructured text &amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;pre&amp;gt;{&amp;lt;br/&amp;gt;
   * &quot;unstructured&quot;: [&amp;lt;br/&amp;gt;    {&amp;lt;br/&amp;gt;      &quot;text&quot;: &quot;Patient has lung cancer, but did not smoke. She may
   * consider chemotherapy as part of a treatment plan.&quot;&amp;lt;br/&amp;gt;    }&amp;lt;br/&amp;gt;
   * ]&amp;lt;br/&amp;gt;}&amp;lt;br/&amp;gt;&amp;lt;/pre&amp;gt;&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;JSON request model with existing annotations
   * &amp;lt;/b&amp;gt;&amp;lt;br/&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;pre&amp;gt;{&amp;lt;br&amp;gt; &quot;unstructured&quot;: [&amp;lt;br&amp;gt;    {&amp;lt;br&amp;gt;      &quot;text&quot;:
   * &quot;Patient will not start on cisplatin 80mg on 1/1/2018. Patient is also diabetic.&quot;,&amp;lt;br&amp;gt;      &quot;data&quot;:
   * {&amp;lt;br&amp;gt;        &quot;concepts&quot;: [&amp;lt;br&amp;gt;          {&amp;lt;br&amp;gt;            &quot;cui&quot;: &quot;C0030705&quot;,&amp;lt;br&amp;gt;
   * &quot;preferredName&quot;: &quot;Patients&quot;,&amp;lt;br&amp;gt;            &quot;semanticType&quot;: &quot;podg&quot;,&amp;lt;br&amp;gt;            &quot;source&quot;:
   * &quot;umls&quot;,&amp;lt;br&amp;gt;            &quot;sourceVersion&quot;: &quot;2017AA&quot;,&amp;lt;br&amp;gt;            &quot;type&quot;:
   * &quot;umls.PatientOrDisabledGroup&quot;,&amp;lt;br&amp;gt;            &quot;begin&quot;: 0,&amp;lt;br&amp;gt;            &quot;end&quot;: 7,&amp;lt;br&amp;gt;
   * &quot;coveredText&quot;: &quot;Patient&quot;&amp;lt;br&amp;gt;          }&amp;lt;br&amp;gt; ]&amp;lt;br&amp;gt;      }  &amp;lt;br&amp;gt;    } &amp;lt;br&amp;gt;
   * ]&amp;lt;br&amp;gt;}&amp;lt;br&amp;gt;&amp;lt;/pre&amp;gt;.
   *
   * @param runPipelineWithFlowOptions the {@link RunPipelineWithFlowOptions} containing the options for the call
   * @return a {@link ServiceCall} with a void result
   */
  public ServiceCall&lt;Void&gt; runPipelineWithFlow(RunPipelineWithFlowOptions runPipelineWithFlowOptions) {
<span class="fc" id="L797">    com.ibm.cloud.sdk.core.util.Validator.notNull(runPipelineWithFlowOptions,</span>
      &quot;runPipelineWithFlowOptions cannot be null&quot;);
<span class="fc" id="L799">    String[] pathSegments = { &quot;v1/analyze&quot; };</span>
<span class="fc" id="L800">    String[] pathParameters = { runPipelineWithFlowOptions.flowId() };</span>
<span class="fc" id="L801">    RequestBuilder builder = RequestBuilder.post(RequestBuilder.constructHttpUrl(getServiceUrl(), pathSegments, pathParameters));</span>
<span class="fc" id="L802">    Map&lt;String, String&gt; sdkHeaders = SdkCommon.getSdkHeaders(&quot;annotator_for_clinical_data_acd&quot;, &quot;v1&quot;, &quot;runPipelineWithFlow&quot;);</span>
<span class="fc bfc" id="L803" title="All 2 branches covered.">    for (Entry&lt;String, String&gt; header : sdkHeaders.entrySet()) {</span>
<span class="fc" id="L804">      builder.header(header.getKey(), header.getValue());</span>
<span class="fc" id="L805">    }</span>
<span class="pc bpc" id="L806" title="1 of 2 branches missed.">    if (runPipelineWithFlowOptions.contentType() != null) {</span>
<span class="fc" id="L807">      builder.header(&quot;Content-Type&quot;, runPipelineWithFlowOptions.contentType());</span>
    }
<span class="fc" id="L809">    builder.query(&quot;version&quot;, this.version);</span>
<span class="fc" id="L810">    builder.query(&quot;return_analyzed_text&quot;, String.valueOf(runPipelineWithFlowOptions.returnAnalyzedText()));</span>
<span class="pc bpc" id="L811" title="1 of 2 branches missed.">    if (runPipelineWithFlowOptions.debugTextRestore() != null) {</span>
<span class="fc" id="L812">      builder.query(&quot;debug_text_restore&quot;, String.valueOf(runPipelineWithFlowOptions.debugTextRestore()));</span>
    }
<span class="fc" id="L814">    builder.bodyContent(runPipelineWithFlowOptions.contentType(), runPipelineWithFlowOptions.analyticFlowBeanInput(),</span>
<span class="fc" id="L815">      null, runPipelineWithFlowOptions.body());</span>
<span class="fc" id="L816">    ResponseConverter&lt;Void&gt; responseConverter = ResponseConverterUtils.getVoid();</span>
<span class="fc" id="L817">    return createServiceCall(builder.build(), responseConverter);</span>
  }

     /**
     * Derive entities and relations from unstructured data.
     *
     * This API accepts a JSON request model featuring both the unstructured data to
     * be analyzed as well as the desired annotator flow.
     *
     * Annotator Chaining Sample request invoking both the concept_detection and
     * symptom_disease annotators asynchronously. { &quot;annotatorFlows&quot;: [ { &quot;flow&quot;: {
     * &quot;elements&quot;: [ { &quot;annotator&quot;: { &quot;name&quot;: &quot;concept_detection&quot; } }, {
     * &quot;annotator&quot;: { &quot;name&quot;: &quot;symptom_disease&quot; } } ], &quot;async&quot;: true } } ],
     * &quot;unstructured\&quot;: [ { &quot;text&quot;: &quot;Patient has lung cancer, but did not smoke. She
     * may consider chemotherapy as part of a treatment plan.&quot; } ] }
     *
     * Annotation Filtering Sample request invoking concept_detection with a filter
     * defined to exclude any annotations derived from concept_detection where the
     * semanticType field does not equal &quot;neop&quot;.
     *
     * { &quot;annotatorFlows&quot;: {&quot;flow&quot;: {&quot;elements&quot;: [{&quot;annotator&quot;: {&quot;name&quot;:
     * &quot;concept_detection&quot;, &quot;configurations&quot;: [ {&quot;filter&quot;: {&quot;target&quot;:
     * &quot;unstructured.data.concepts&quot;,&quot;condition&quot;: { &quot;type&quot;: &quot;match&quot;, &quot;field&quot;:
     * &quot;semanticType&quot;, &quot;values&quot;: [&quot;neop&quot;], &quot;not&quot;: false, &quot;caseInsensitive&quot;: false,
     * &quot;operator&quot;: &quot;equals&quot; } }}]}}], &quot;async&quot;: false }}], unstructured&quot;: [{&quot;text&quot;:
     * &quot;Patient has lung cancer, but did not smoke. She may consider chemotherapy as
     * part of a treatment plan.&quot;} ]}Annotators that support annotation filtering:
     * allergy, bathing_assistance, cancer, concept_detection, dressing_assistance,
     * eating_assistance, ejection_fraction, lab_value, medication, named_entities,
     * procedure, seeing_assistance, smoking, symptom_disease, toileting_assistance,
     * walking_assistance. Annotation Augmentation Sample request invoking the
     * cancer annotator and providing a whitelist entry for a new custom surface
     * form: &quot;lungcancer&quot;. {&quot;annotatorFlows&quot;: [{&quot;flow&quot;: {&quot;elements&quot;: [ {
     * &quot;annotator&quot;: {&quot;name&quot;: &quot;cancer&quot;, &quot;configurations&quot;: [{&quot;whitelist&quot;: {&quot;name&quot;:
     * &quot;cancer&quot;,&quot;entries&quot;: [ {&quot;surfaceForms&quot;: [&quot;lungcancer&quot;],&quot;features&quot;:
     * {&quot;normalizedName&quot;: &quot;lung cancer&quot;, &quot;hccCode&quot;: &quot;9&quot;, &quot;icd10Code&quot;: &quot;C34.9&quot;,
     * &quot;ccsCode&quot;: &quot;19&quot;, &quot;icd9Code&quot;: &quot;162.9&quot;, &quot;conceptId&quot;: &quot;93880001&quot; } }]}}]}}],
     * &quot;async&quot;: false}}], &quot;unstructured&quot;: [{&quot;text&quot;: &quot;The patient was diagnosed with
     * lungcancer, on Dec 23, 2011.&quot; }]}
     *
     * Annotators that support annotation augmentation: allergy, bathing_assistance,
     * cancer, dressing_assistance, eating_assistance, ejection_fraction, lab_value,
     * medication, named_entities, procedure, seeing_assistance, smoking,
     * symptom_disease, toileting_assistance, walking_assistance. .
     *
     * @param analyzeOptions the {@link AnalyzeOptions} containing the options for
     *                       the call
     * @return the service call
     */
    public ServiceCall&lt;ContainerGroup&gt; analyze(final AnalyzeOptions analyzeOptions) {
<span class="nc" id="L867">      Validator.notNull(analyzeOptions, &quot;analyzeOptions cannot be null&quot;);</span>
<span class="nc" id="L868">      String[] pathSegments = { &quot;v1/analyze&quot; };</span>
<span class="nc" id="L869">      RequestBuilder builder = RequestBuilder.post(RequestBuilder.constructHttpUrl(getServiceUrl(), pathSegments));</span>
<span class="nc" id="L870">      builder.query(VERSION, version);</span>
<span class="nc" id="L871">      builder.query(RETURN_ANALYZED_TEXT, String.valueOf(analyzeOptions.returnAnalyzedText()));</span>
<span class="nc" id="L872">      Map&lt;String, String&gt; sdkHeaders = SdkCommon.getSdkHeaders(DEFAULT_SERVICE_NAME, &quot;v1&quot;, &quot;analyze&quot;);</span>
<span class="nc bnc" id="L873" title="All 2 branches missed.">      for (Entry&lt;String, String&gt; header : sdkHeaders.entrySet()) {</span>
<span class="nc" id="L874">          builder.header(header.getKey(), header.getValue());</span>
<span class="nc" id="L875">      }</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">      if (analyzeOptions != null) {</span>
<span class="nc" id="L877">          final JsonObject contentJson = new JsonObject();</span>
<span class="nc bnc" id="L878" title="All 2 branches missed.">          if (analyzeOptions.unstructured() != null) {</span>
<span class="nc" id="L879">              contentJson.add(&quot;unstructured&quot;, GsonSingleton.getGson().toJsonTree(analyzeOptions.unstructured()));</span>
          }
<span class="nc bnc" id="L881" title="All 2 branches missed.">          if (analyzeOptions.annotatorFlows() != null) {</span>
<span class="nc" id="L882">              contentJson.add(&quot;annotatorFlows&quot;, GsonSingleton.getGson().toJsonTree(analyzeOptions.annotatorFlows()));</span>
          }
<span class="nc" id="L884">          builder.bodyJson(contentJson);</span>
      }
<span class="nc" id="L886">      return createServiceCall(builder.build(), ResponseConverterUtils.getObject(ContainerGroup.class));</span>
  }

  /**
   * analyze with a persisted flow.
   *
   * This API accepts a flow identifier as well as a TEXT or a JSON request model
   * featuring the unstructured text to be analyzed. JSON request model with
   * unstructured text
   *
   * { &quot;unstructured&quot;: [ {&quot;text&quot;: &quot;Patient has lung cancer, but did not smoke. She
   * may consider chemotherapy as part of a treatment plan.&quot; } ]} JSON request
   * model with existing annotations {&quot;unstructured&quot;: [{&quot;text&quot;: &quot;Patient will not
   * start on cisplatin 80mg on 1/1/2018. Patient is also diabetic.&quot;, &quot;data&quot;:
   * {&quot;concepts&quot;: [{&quot;cui&quot;: &quot;C0030705&quot;, &quot;preferredName&quot;: &quot;Patients&quot;,
   * &quot;semanticType&quot;: &quot;podg&quot;, &quot;source&quot;: &quot;umls&quot;, &quot;sourceVersion&quot;: &quot;2017AA&quot;, &quot;type&quot;:
   * &quot;umls.PatientOrDisabledGroup&quot;, &quot;begin&quot;: 0, &quot;end&quot;: 7, &quot;coveredText&quot;:
   * &quot;Patient&quot;}]}}]} .
   *
   * @param analyzeWithFlowOptions the {@link AnalyzeWithFlowOptions} containing
   *                               the options for the call
   * @return the service call
   */
  public ServiceCall&lt;ContainerGroup&gt; analyzeWithFlow(final AnalyzeWithFlowOptions analyzeWithFlowOptions) {
<span class="nc" id="L910">      Validator.notNull(analyzeWithFlowOptions, &quot;analyzeWithFlowOptions cannot be null&quot;);</span>
<span class="nc" id="L911">      String[] pathSegments = { &quot;v1/analyze&quot; };</span>
<span class="nc" id="L912">      String[] pathParameters = { analyzeWithFlowOptions.flowId() };</span>
<span class="nc" id="L913">      RequestBuilder builder = RequestBuilder</span>
<span class="nc" id="L914">              .post(RequestBuilder.constructHttpUrl(getServiceUrl(), pathSegments, pathParameters));</span>
<span class="nc" id="L915">      Map&lt;String, String&gt; sdkHeaders = SdkCommon.getSdkHeaders(DEFAULT_SERVICE_NAME, &quot;v1&quot;, &quot;analyzeWithFlow&quot;);</span>
<span class="nc bnc" id="L916" title="All 2 branches missed.">      for (Entry&lt;String, String&gt; header : sdkHeaders.entrySet()) {</span>
<span class="nc" id="L917">          builder.header(header.getKey(), header.getValue());</span>
<span class="nc" id="L918">      }</span>
<span class="nc" id="L919">      builder.query(VERSION, version);</span>
<span class="nc" id="L920">      builder.query(RETURN_ANALYZED_TEXT, String.valueOf(analyzeWithFlowOptions.returnAnalyzedText()));</span>
<span class="nc" id="L921">      builder.header(&quot;content-type&quot;, analyzeWithFlowOptions.contentType());</span>

<span class="nc" id="L923">      if (analyzeWithFlowOptions.contentType()</span>
<span class="nc bnc" id="L924" title="All 2 branches missed.">              .equalsIgnoreCase(AnalyzeWithFlowOptions.ContentType.APPLICATION_JSON)) {</span>
<span class="nc" id="L925">          builder.bodyJson(GsonSingleton.getGson().toJsonTree(analyzeWithFlowOptions.request()).getAsJsonObject());</span>
      } else {
<span class="nc" id="L927">          builder.bodyContent(analyzeWithFlowOptions.body(), analyzeWithFlowOptions.contentType());</span>
      }
<span class="nc" id="L929">      return createServiceCall(builder.build(), ResponseConverterUtils.getObject(ContainerGroup.class));</span>
  }

      /**
     * Method to analyze text with a manually defined annotator flow.
     *
     * @param text data to be analyzed
     * @param flow {@link Flow} analytics to apply to the text
     *
     * @return the {@link ContainerGroup} discovered cogntive artifacts
     */

    public ContainerGroup analyze(final String text, final Flow flow) {
<span class="nc" id="L942">      AnnotatorFlow annotatorFlow = new AnnotatorFlow.Builder().flow(flow).build();</span>
<span class="nc" id="L943">      UnstructuredContainer unstructuredContainer = new UnstructuredContainer.Builder().text(text).build();</span>
<span class="nc" id="L944">      AnalyzeOptions options = new AnalyzeOptions.Builder().addUnstructured(unstructuredContainer)</span>
<span class="nc" id="L945">              .returnAnalyzedText(false).addAnnotatorFlows(annotatorFlow).build();</span>

<span class="nc" id="L947">      return this.analyze(options).execute().getResult();</span>
  }

  /**
   * Method to analyze text with a manually defined annotator flow.
   *
   * @param text data to be analyzed
   * @param flow {@link Flow} analytics to apply to the text
   *
   * @return the response with {@link ContainerGroup}
   */

  public Response&lt;ContainerGroup&gt; analyzeInclResponseDetails(final String text, final Flow flow) {
<span class="nc" id="L960">      AnnotatorFlow annotatorFlow = new AnnotatorFlow.Builder().flow(flow).build();</span>
<span class="nc" id="L961">      UnstructuredContainer unstructuredContainer = new UnstructuredContainer.Builder().text(text).build();</span>
<span class="nc" id="L962">      AnalyzeOptions options = new AnalyzeOptions.Builder().addUnstructured(unstructuredContainer)</span>
<span class="nc" id="L963">              .returnAnalyzedText(false).addAnnotatorFlows(annotatorFlow).build();</span>

<span class="nc" id="L965">      return this.analyze(options).execute();</span>
  }

  /**
   * Method to analyze text with a manually defined annotator flow.
   *
   * @param text data to be analyzed
   * @param flow analytics to appply to the text {@link Flow}
   * @param returnAnalyzedText where to return the submitted data
   *
   * @return the {@link ContainerGroup}
   */

  public ContainerGroup analyze(final String text, final Flow flow, final boolean returnAnalyzedText) {
<span class="nc" id="L979">      AnnotatorFlow annotatorFlow = new AnnotatorFlow.Builder().flow(flow).build();</span>
<span class="nc" id="L980">      UnstructuredContainer unstructuredContainer = new UnstructuredContainer.Builder().text(text).build();</span>
<span class="nc" id="L981">      AnalyzeOptions options = new AnalyzeOptions.Builder().addUnstructured(unstructuredContainer)</span>
<span class="nc" id="L982">              .returnAnalyzedText(returnAnalyzedText).addAnnotatorFlows(annotatorFlow).build();</span>

<span class="nc" id="L984">      return this.analyze(options).execute().getResult();</span>
  }

  /**
   * Method to analyze text with a manually defined annotator flow.
   *
   * @param text data to be analyzed
   * @param flow  analytics to appply to the text {@link Flow}
   * @param returnAnalyzedText where to return the submitted data
   *
   * @return the resopnse with result representing {@link ContainerGroup}
   */

  public Response&lt;ContainerGroup&gt; analyzeInclResponseDetails(final String text, final Flow flow,
          final boolean returnAnalyzedText) {
<span class="nc" id="L999">      AnnotatorFlow annotatorFlow = new AnnotatorFlow.Builder().flow(flow).build();</span>
<span class="nc" id="L1000">      UnstructuredContainer unstructuredContainer = new UnstructuredContainer.Builder().text(text).build();</span>
<span class="nc" id="L1001">      AnalyzeOptions options = new AnalyzeOptions.Builder().addUnstructured(unstructuredContainer)</span>
<span class="nc" id="L1002">              .returnAnalyzedText(returnAnalyzedText).addAnnotatorFlows(annotatorFlow).build();</span>

<span class="nc" id="L1004">      return this.analyze(options).execute();</span>
  }

  /**
   * Method to analyze text with an existing annotator flow.
   *
   * @param flowId identifier of existing analytic flow to apply to the text
   * @param text data to be analyzed
   *
   * @return the {@link ContainerGroup}
   */

  public ContainerGroup analyzeWithFlow(final String flowId, final String text) {
<span class="nc" id="L1017">      AnalyzeWithFlowOptions analyzeWithFlowOptions = new AnalyzeWithFlowOptions.Builder().flowId(flowId).text(text)</span>
<span class="nc" id="L1018">              .returnAnalyzedText(false).build();</span>

<span class="nc" id="L1020">      return this.analyzeWithFlow(analyzeWithFlowOptions).execute().getResult();</span>
  }

  /**
   * Method to analyze text with an existing annotator flow.
   *
   * @param flowId identifier of existing analytic flow to apply to the text
   * @param text data to be analyzed
   *
   * @return the resopnse with result representing {@link ContainerGroup}
   */

  public Response&lt;ContainerGroup&gt; analyzeWithFlowInclResponseDetails(final String flowId, final String text) {
<span class="nc" id="L1033">      AnalyzeWithFlowOptions analyzeWithFlowOptions = new AnalyzeWithFlowOptions.Builder().flowId(flowId).text(text)</span>
<span class="nc" id="L1034">              .returnAnalyzedText(false).build();</span>

<span class="nc" id="L1036">      return this.analyzeWithFlow(analyzeWithFlowOptions).execute();</span>
  }

  /**
   * Method to analyze text with an existing annotator flow.
   *
   * @param flowId identifier of existing analytic flow to apply to the text
   * @param text data to be analyzed
   * @param returnAnalyzedText where to return the submitted data
   *
   * @return the resopnse with result representing {@link ContainerGroup}
   */

  public ContainerGroup analyzeWithFlow(final String flowId, final String text, final boolean returnAnalyzedText) {
<span class="nc" id="L1050">      AnalyzeWithFlowOptions analyzeWithFlowOptions = new AnalyzeWithFlowOptions.Builder().flowId(flowId).text(text)</span>
<span class="nc" id="L1051">              .returnAnalyzedText(returnAnalyzedText).build();</span>

<span class="nc" id="L1053">      return this.analyzeWithFlow(analyzeWithFlowOptions).execute().getResult();</span>
  }

  /**
   * Method to analyze text with an existing annotator flow.
   *
   * @param flowId identifier of existing analytic flow to apply to the text
   * @param text data to be analyzed
   * @param returnAnalyzedText where to return the submitted data
   *
   * @return the resopnse with result representing {@link ContainerGroup}
   */

  public Response&lt;ContainerGroup&gt; analyzeWithFlowInclResponseDetails(final String flowId, final String text,
          final boolean returnAnalyzedText) {
<span class="nc" id="L1068">      AnalyzeWithFlowOptions analyzeWithFlowOptions = new AnalyzeWithFlowOptions.Builder().flowId(flowId).text(text)</span>
<span class="nc" id="L1069">              .returnAnalyzedText(returnAnalyzedText).build();</span>

<span class="nc" id="L1071">      return this.analyzeWithFlow(analyzeWithFlowOptions).execute();</span>
  }

  /**
   * Method to analyze text with an existing annotator flow.
   *
   * @param flowId identifier of existing analytic flow to apply to the text
   * @param unstructuredContainer {@link UnstructuredContainer} discovered cogntive artifacts
   *
   * @return the {@link ContainerGroup}
   */

  public ContainerGroup analyzeWithFlow(final String flowId, final UnstructuredContainer unstructuredContainer) {
<span class="nc" id="L1084">      RequestContainer requestContainer = new RequestContainer.Builder().addUnstructured(unstructuredContainer)</span>
<span class="nc" id="L1085">              .build();</span>

<span class="nc" id="L1087">      AnalyzeWithFlowOptions analyzeWithFlowOptions = new AnalyzeWithFlowOptions.Builder().flowId(flowId)</span>
<span class="nc" id="L1088">              .returnAnalyzedText(false).request(requestContainer).build();</span>

<span class="nc" id="L1090">      return this.analyzeWithFlow(analyzeWithFlowOptions).execute().getResult();</span>
  }

  /**
   * Method to analyze text with an existing annotator flow.
   *
   * @param flowId identifier of existing analytic flow to apply to the text
   * @param unstructuredContainer {@link UnstructuredContainer} discovered cogntive artifacts
   *
   * @return the resopnse with result representing {@link ContainerGroup}
   */

  public Response&lt;ContainerGroup&gt; analyzeWithFlowInclResponseDetails(final String flowId,
          final UnstructuredContainer unstructuredContainer) {
<span class="nc" id="L1104">      RequestContainer requestContainer = new RequestContainer.Builder().addUnstructured(unstructuredContainer)</span>
<span class="nc" id="L1105">              .build();</span>

<span class="nc" id="L1107">      AnalyzeWithFlowOptions analyzeWithFlowOptions = new AnalyzeWithFlowOptions.Builder().flowId(flowId)</span>
<span class="nc" id="L1108">              .returnAnalyzedText(false).request(requestContainer).build();</span>

<span class="nc" id="L1110">      return this.analyzeWithFlow(analyzeWithFlowOptions).execute();</span>
  }

  /**
   * Method to analyze text with an existing annotator flow.
   *
   * @param flowId identifier of existing analytic flow to apply to the text
   * @param unstructuredContainer {@link UnstructuredContainer}
   * @param returnAnalyzedText where to return the submitted data
   *
   * @return the {@link ContainerGroup} discovered cogntive artifacts
   */

  public ContainerGroup analyzeWithFlow(final String flowId, final UnstructuredContainer unstructuredContainer,
          final boolean returnAnalyzedText) {
<span class="nc" id="L1125">      RequestContainer requestContainer = new RequestContainer.Builder().addUnstructured(unstructuredContainer)</span>
<span class="nc" id="L1126">              .build();</span>

<span class="nc" id="L1128">      AnalyzeWithFlowOptions analyzeWithFlowOptions = new AnalyzeWithFlowOptions.Builder().flowId(flowId)</span>
<span class="nc" id="L1129">              .returnAnalyzedText(returnAnalyzedText).request(requestContainer).build();</span>

<span class="nc" id="L1131">      return this.analyzeWithFlow(analyzeWithFlowOptions).execute().getResult();</span>
  }

  /**
   * Method to analyze text with an existing annotator flow.
   *
   * @param flowId identifier of existing analytic flow to apply to the text
   * @param unstructuredContainer {@link UnstructuredContainer}
   * @param returnAnalyzedText where to return the submitted data
   *
   * @return the resopnse with result representing {@link ContainerGroup}
   */

  public Response&lt;ContainerGroup&gt; analyzeWithFlowInclResponseDetails(final String flowId,
          final UnstructuredContainer unstructuredContainer, final boolean returnAnalyzedText) {
<span class="nc" id="L1146">      RequestContainer requestContainer = new RequestContainer.Builder().addUnstructured(unstructuredContainer)</span>
<span class="nc" id="L1147">              .build();</span>

<span class="nc" id="L1149">      AnalyzeWithFlowOptions analyzeWithFlowOptions = new AnalyzeWithFlowOptions.Builder().flowId(flowId)</span>
<span class="nc" id="L1150">              .returnAnalyzedText(returnAnalyzedText).request(requestContainer).build();</span>

<span class="nc" id="L1152">      return this.analyzeWithFlow(analyzeWithFlowOptions).execute();</span>
  }

  /**
   * Get list of available annotators.
   *
   * Get list of available annotators that can be leveraged to detect information from unstructured data. One or more
   * annnotators can be leveraged within a single request to the service.
   *
   * @param getAnnotatorsOptions the {@link GetAnnotatorsOptions} containing the options for the call
   * @return a {@link ServiceCall} with a void result
   */
  public ServiceCall&lt;Map&lt;String, ServiceApiBean&gt;&gt; getAnnotators(GetAnnotatorsOptions getAnnotatorsOptions) {
<span class="fc" id="L1165">    String[] pathSegments = { &quot;v1/annotators&quot; };</span>
<span class="fc" id="L1166">    RequestBuilder builder = RequestBuilder.get(RequestBuilder.constructHttpUrl(getServiceUrl(), pathSegments));</span>
<span class="fc" id="L1167">    Map&lt;String, String&gt; sdkHeaders = SdkCommon.getSdkHeaders(&quot;annotator_for_clinical_data_acd&quot;, &quot;v1&quot;, &quot;getAnnotators&quot;);</span>
<span class="fc bfc" id="L1168" title="All 2 branches covered.">    for (Entry&lt;String, String&gt; header : sdkHeaders.entrySet()) {</span>
<span class="fc" id="L1169">      builder.header(header.getKey(), header.getValue());</span>
<span class="fc" id="L1170">    }</span>
<span class="pc bpc" id="L1171" title="1 of 2 branches missed.">    if (getAnnotatorsOptions != null) {</span>
<span class="fc" id="L1172">      builder.query(&quot;version&quot;, this.version);</span>
    }
<span class="fc" id="L1174">    ResponseConverter&lt;Map&lt;String, ServiceApiBean&gt;&gt; responseConverter =</span>
<span class="fc" id="L1175">    		ResponseConverterUtils.getValue(new com.google.gson.reflect.TypeToken&lt;Map&lt;String, ServiceApiBean&gt;&gt;() { }.getType());</span>
<span class="fc" id="L1176">    return createServiceCall(builder.build(), responseConverter);</span>
  }

  /**
   * Get list of available annotators.
   *
   * Get list of available annotators that can be leveraged to detect information from unstructured data. One or more
   * annnotators can be leveraged within a single request to the service.
   *
   * @return a {@link ServiceCall} with a void result
   */
  public ServiceCall&lt;Map&lt;String, ServiceApiBean&gt;&gt; getAnnotators() {
<span class="nc" id="L1188">    return getAnnotators(null);</span>
  }

  /**
   * Get details of a specific annotator.
   *
   * Get details of an annotator that can be used to detect information from unstructured data.
   *
   * @param getAnnotatorsByIdOptions the {@link GetAnnotatorsByIdOptions} containing the options for the call
   * @return a {@link ServiceCall} with a void result
   */
  public ServiceCall&lt;Annotator&gt; getAnnotatorsById(GetAnnotatorsByIdOptions getAnnotatorsByIdOptions) {
<span class="fc" id="L1200">    com.ibm.cloud.sdk.core.util.Validator.notNull(getAnnotatorsByIdOptions,</span>
      &quot;getAnnotatorsByIdOptions cannot be null&quot;);
<span class="fc" id="L1202">    String[] pathSegments = { &quot;v1/annotators&quot; };</span>
<span class="fc" id="L1203">    String[] pathParameters = { getAnnotatorsByIdOptions.id() };</span>
<span class="fc" id="L1204">    RequestBuilder builder = RequestBuilder.get(RequestBuilder.constructHttpUrl(getServiceUrl(), pathSegments, pathParameters));</span>
<span class="fc" id="L1205">    Map&lt;String, String&gt; sdkHeaders = SdkCommon.getSdkHeaders(&quot;annotator_for_clinical_data_acd&quot;, &quot;v1&quot;, &quot;getAnnotatorsById&quot;);</span>
<span class="fc bfc" id="L1206" title="All 2 branches covered.">    for (Entry&lt;String, String&gt; header : sdkHeaders.entrySet()) {</span>
<span class="fc" id="L1207">      builder.header(header.getKey(), header.getValue());</span>
<span class="fc" id="L1208">    }</span>
<span class="fc" id="L1209">    builder.query(&quot;version&quot;, this.version);</span>
<span class="fc" id="L1210">    ResponseConverter&lt;Annotator&gt; responseConverter = ResponseConverterUtils.getValue(new com.google.gson.reflect.TypeToken&lt;Annotator&gt;() { }.getType());</span>
<span class="fc" id="L1211">    return createServiceCall(builder.build(), responseConverter);</span>
  }

  /**
   * Delete tenant specific artifacts.
   *
   * Delete tenant specific artifacts.
   *
   * @param deleteUserSpecificArtifactsOptions the {@link DeleteUserSpecificArtifactsOptions} containing the options for the call
   * @return a {@link ServiceCall} with a void result
   */
  public ServiceCall&lt;Void&gt; deleteUserSpecificArtifacts(DeleteUserSpecificArtifactsOptions deleteUserSpecificArtifactsOptions) {
<span class="fc" id="L1223">    String[] pathSegments = { &quot;v1/user_data&quot; };</span>
<span class="fc" id="L1224">    RequestBuilder builder = RequestBuilder.delete(RequestBuilder.constructHttpUrl(getServiceUrl(), pathSegments));</span>
<span class="fc" id="L1225">    Map&lt;String, String&gt; sdkHeaders = SdkCommon.getSdkHeaders(&quot;annotator_for_clinical_data_acd&quot;, &quot;v1&quot;, &quot;deleteUserSpecificArtifacts&quot;);</span>
<span class="fc bfc" id="L1226" title="All 2 branches covered.">    for (Entry&lt;String, String&gt; header : sdkHeaders.entrySet()) {</span>
<span class="fc" id="L1227">      builder.header(header.getKey(), header.getValue());</span>
<span class="fc" id="L1228">    }</span>
<span class="pc bpc" id="L1229" title="1 of 2 branches missed.">    if (deleteUserSpecificArtifactsOptions != null) {</span>
<span class="fc" id="L1230">      builder.query(&quot;version&quot;, this.version);</span>
    }
<span class="fc" id="L1232">    ResponseConverter&lt;Void&gt; responseConverter = ResponseConverterUtils.getVoid();</span>
<span class="fc" id="L1233">    return createServiceCall(builder.build(), responseConverter);</span>
  }

  /**
   * Delete tenant specific artifacts.
   *
   * Delete tenant specific artifacts.
   *
   * @return a {@link ServiceCall} with a void result
   */
  public ServiceCall&lt;Void&gt; deleteUserSpecificArtifacts() {
<span class="nc" id="L1244">    return deleteUserSpecificArtifacts(null);</span>
  }

  /**
   * Get list of available deployment status.
   *
   * Returns a summary including ID and status of the available deployments.
   *
   * @param cartridgesGetOptions the {@link CartridgesGetOptions} containing the options for the call
   * @return a {@link ServiceCall} with a result of type {@link ListStringWrapper}
   */
  public ServiceCall&lt;AcdCartridgesList&gt; cartridgesGet(CartridgesGetOptions cartridgesGetOptions) {
<span class="fc" id="L1256">    String[] pathSegments = { &quot;v1/cartridges&quot; };</span>
<span class="fc" id="L1257">    RequestBuilder builder = RequestBuilder.get(RequestBuilder.constructHttpUrl(getServiceUrl(), pathSegments));</span>
<span class="fc" id="L1258">    Map&lt;String, String&gt; sdkHeaders = SdkCommon.getSdkHeaders(&quot;annotator_for_clinical_data_acd&quot;, &quot;v1&quot;, &quot;cartridgesGet&quot;);</span>
<span class="fc bfc" id="L1259" title="All 2 branches covered.">    for (Entry&lt;String, String&gt; header : sdkHeaders.entrySet()) {</span>
<span class="fc" id="L1260">      builder.header(header.getKey(), header.getValue());</span>
<span class="fc" id="L1261">    }</span>
<span class="fc" id="L1262">    builder.header(&quot;Accept&quot;, &quot;application/json&quot;);</span>
<span class="pc bpc" id="L1263" title="1 of 2 branches missed.">    if (cartridgesGetOptions != null) {</span>
<span class="fc" id="L1264">      builder.query(&quot;version&quot;, this.version);</span>
    }
<span class="fc" id="L1266">    ResponseConverter&lt;AcdCartridgesList&gt; responseConverter =</span>
<span class="fc" id="L1267">      ResponseConverterUtils.getValue(new com.google.gson.reflect.TypeToken&lt;AcdCartridgesList&gt;() { }.getType());</span>
<span class="fc" id="L1268">    return createServiceCall(builder.build(), responseConverter);</span>
  }

  /**
   * Get list of available deployment status.
   *
   * Returns a summary including ID and status of the available deployments.
   *
   * @return a {@link ServiceCall} with a result of type {@link ListStringWrapper}
   */
  public ServiceCall&lt;AcdCartridgesList&gt; cartridgesGet() {
<span class="nc" id="L1279">    return cartridgesGet(null);</span>
  }

  /**
   * Create a cartridge deployment.
   *
   * Create a cartridge deployment from a cartridge archive file.
   *
   * @param cartridgesPostMultipartOptions the {@link CartridgesPostMultipartOptions} containing the options for the call
   * @return a {@link ServiceCall} with a result of type {@link DeployCartridgeResponse}
   */
  public ServiceCall&lt;DeployCartridgeResponse&gt; cartridgesPostMultipart(CartridgesPostMultipartOptions cartridgesPostMultipartOptions) {
<span class="fc" id="L1291">    com.ibm.cloud.sdk.core.util.Validator.notNull(cartridgesPostMultipartOptions,</span>
      &quot;cartridgesPostMultipartOptions cannot be null&quot;);
<span class="pc bpc" id="L1293" title="1 of 2 branches missed.">    com.ibm.cloud.sdk.core.util.Validator.isTrue((cartridgesPostMultipartOptions.archiveFile() != null), &quot;At least one of  or archiveFile must be supplied.&quot;);</span>
<span class="fc" id="L1294">    String[] pathSegments = { &quot;v1/cartridges&quot; };</span>
<span class="fc" id="L1295">    RequestBuilder builder = RequestBuilder.post(RequestBuilder.constructHttpUrl(getServiceUrl(), pathSegments));</span>
<span class="fc" id="L1296">    Map&lt;String, String&gt; sdkHeaders = SdkCommon.getSdkHeaders(&quot;annotator_for_clinical_data_acd&quot;, &quot;v1&quot;, &quot;cartridgesPostMultipart&quot;);</span>
<span class="fc bfc" id="L1297" title="All 2 branches covered.">    for (Entry&lt;String, String&gt; header : sdkHeaders.entrySet()) {</span>
<span class="fc" id="L1298">      builder.header(header.getKey(), header.getValue());</span>
<span class="fc" id="L1299">    }</span>
<span class="fc" id="L1300">    builder.header(&quot;Accept&quot;, &quot;application/json&quot;);</span>
<span class="fc" id="L1301">    builder.query(&quot;version&quot;, this.version);</span>
<span class="fc" id="L1302">    MultipartBody.Builder multipartBuilder = new MultipartBody.Builder();</span>
<span class="fc" id="L1303">    multipartBuilder.setType(MultipartBody.FORM);</span>
<span class="pc bpc" id="L1304" title="1 of 2 branches missed.">    if (cartridgesPostMultipartOptions.archiveFile() != null) {</span>
<span class="fc" id="L1305">      okhttp3.RequestBody archiveFileBody = RequestUtils.inputStreamBody(cartridgesPostMultipartOptions.archiveFile(), cartridgesPostMultipartOptions.archiveFileContentType());</span>
<span class="fc" id="L1306">      multipartBuilder.addFormDataPart(&quot;archive_file&quot;, &quot;filename&quot;, archiveFileBody);</span>
    }
<span class="fc" id="L1308">    builder.body(multipartBuilder.build());</span>
<span class="fc" id="L1309">    ResponseConverter&lt;DeployCartridgeResponse&gt; responseConverter =</span>
<span class="fc" id="L1310">      ResponseConverterUtils.getValue(new com.google.gson.reflect.TypeToken&lt;DeployCartridgeResponse&gt;() { }.getType());</span>
<span class="fc" id="L1311">    return createServiceCall(builder.build(), responseConverter);</span>
  }

  /**
   * Create a cartridge deployment.
   *
   * Create a cartridge deployment from a cartridge archive file.
   *
   * @return a {@link ServiceCall} with a result of type {@link DeployCartridgeResponse}
   */
  public ServiceCall&lt;DeployCartridgeResponse&gt; cartridgesPostMultipart() {
<span class="nc" id="L1322">    return cartridgesPostMultipart(null);</span>
  }

  /**
   * Create a cartridge deployment.
   *
   * Update a cartridge deployment from a cartridge archive file.
   *
   * @param cartridgesPutMultipartOptions the {@link CartridgesPutMultipartOptions} containing the options for the call
   * @return a {@link ServiceCall} with a result of type {@link DeployCartridgeResponse}
   */
  public ServiceCall&lt;DeployCartridgeResponse&gt; cartridgesPutMultipart(CartridgesPutMultipartOptions cartridgesPutMultipartOptions) {
<span class="fc" id="L1334">    com.ibm.cloud.sdk.core.util.Validator.notNull(cartridgesPutMultipartOptions,</span>
      &quot;cartridgesPutMultipartOptions cannot be null&quot;);
<span class="pc bpc" id="L1336" title="1 of 2 branches missed.">    com.ibm.cloud.sdk.core.util.Validator.isTrue((cartridgesPutMultipartOptions.archiveFile() != null), &quot;At least one of  or archiveFile must be supplied.&quot;);</span>
<span class="fc" id="L1337">    String[] pathSegments = { &quot;v1/cartridges&quot; };</span>
<span class="fc" id="L1338">    RequestBuilder builder = RequestBuilder.put(RequestBuilder.constructHttpUrl(getServiceUrl(), pathSegments));</span>
<span class="fc" id="L1339">    Map&lt;String, String&gt; sdkHeaders = SdkCommon.getSdkHeaders(&quot;annotator_for_clinical_data_acd&quot;, &quot;v1&quot;, &quot;cartridgesPutMultipart&quot;);</span>
<span class="fc bfc" id="L1340" title="All 2 branches covered.">    for (Entry&lt;String, String&gt; header : sdkHeaders.entrySet()) {</span>
<span class="fc" id="L1341">      builder.header(header.getKey(), header.getValue());</span>
<span class="fc" id="L1342">    }</span>
<span class="fc" id="L1343">    builder.header(&quot;Accept&quot;, &quot;application/json&quot;);</span>
<span class="fc" id="L1344">    builder.query(&quot;version&quot;, this.version);</span>
<span class="fc" id="L1345">    MultipartBody.Builder multipartBuilder = new MultipartBody.Builder();</span>
<span class="fc" id="L1346">    multipartBuilder.setType(MultipartBody.FORM);</span>
<span class="pc bpc" id="L1347" title="1 of 2 branches missed.">    if (cartridgesPutMultipartOptions.archiveFile() != null) {</span>
<span class="fc" id="L1348">      okhttp3.RequestBody archiveFileBody = RequestUtils.inputStreamBody(cartridgesPutMultipartOptions.archiveFile(), cartridgesPutMultipartOptions.archiveFileContentType());</span>
<span class="fc" id="L1349">      multipartBuilder.addFormDataPart(&quot;archive_file&quot;, &quot;filename&quot;, archiveFileBody);</span>
    }
<span class="fc" id="L1351">    builder.body(multipartBuilder.build());</span>
<span class="fc" id="L1352">    ResponseConverter&lt;DeployCartridgeResponse&gt; responseConverter =</span>
<span class="fc" id="L1353">      ResponseConverterUtils.getValue(new com.google.gson.reflect.TypeToken&lt;DeployCartridgeResponse&gt;() { }.getType());</span>
<span class="fc" id="L1354">    return createServiceCall(builder.build(), responseConverter);</span>
  }

  /**
   * Create a cartridge deployment.
   *
   * Update a cartridge deployment from a cartridge archive file.
   *
   * @return a {@link ServiceCall} with a result of type {@link DeployCartridgeResponse}
   */
  public ServiceCall&lt;DeployCartridgeResponse&gt; cartridgesPutMultipart() {
<span class="nc" id="L1365">    return cartridgesPutMultipart(null);</span>
  }

  /**
   * Get details of a specific deployment.
   *
   * Using the specified Catridge ID, retrieves the deployment status.
   *
   * @param cartridgesGetIdOptions the {@link CartridgesGetIdOptions} containing the options for the call
   * @return a {@link ServiceCall} with a result of type {@link AcdCartridges}
   */
  public ServiceCall&lt;AcdCartridges&gt; cartridgesGetId(CartridgesGetIdOptions cartridgesGetIdOptions) {
<span class="fc" id="L1377">    com.ibm.cloud.sdk.core.util.Validator.notNull(cartridgesGetIdOptions,</span>
      &quot;cartridgesGetIdOptions cannot be null&quot;);
<span class="fc" id="L1379">    String[] pathSegments = { &quot;v1/cartridges&quot; };</span>
<span class="fc" id="L1380">    String[] pathParameters = { cartridgesGetIdOptions.id() };</span>
<span class="fc" id="L1381">    RequestBuilder builder = RequestBuilder.get(RequestBuilder.constructHttpUrl(getServiceUrl(), pathSegments, pathParameters));</span>
<span class="fc" id="L1382">    Map&lt;String, String&gt; sdkHeaders = SdkCommon.getSdkHeaders(&quot;annotator_for_clinical_data_acd&quot;, &quot;v1&quot;, &quot;cartridgesGetId&quot;);</span>
<span class="fc bfc" id="L1383" title="All 2 branches covered.">    for (Entry&lt;String, String&gt; header : sdkHeaders.entrySet()) {</span>
<span class="fc" id="L1384">      builder.header(header.getKey(), header.getValue());</span>
<span class="fc" id="L1385">    }</span>
<span class="fc" id="L1386">    builder.header(&quot;Accept&quot;, &quot;application/json&quot;);</span>
<span class="fc" id="L1387">    builder.query(&quot;version&quot;, this.version);</span>
<span class="fc" id="L1388">    ResponseConverter&lt;AcdCartridges&gt; responseConverter =</span>
<span class="fc" id="L1389">      ResponseConverterUtils.getValue(new com.google.gson.reflect.TypeToken&lt;AcdCartridges&gt;() { }.getType());</span>
<span class="fc" id="L1390">    return createServiceCall(builder.build(), responseConverter);</span>
  }

  /**
   * Deploy a cartridge.
   *
   * Deploy a cartridge from a cartridge archive file.
   *
   * @param deployCartridgeOptions the {@link DeployCartridgeOptions} containing the options for the call
   * @return a {@link ServiceCall} with a result of type {@link DeployCartridgeResponse}
   */
  public ServiceCall&lt;DeployCartridgeResponse&gt; deployCartridge(DeployCartridgeOptions deployCartridgeOptions) {
<span class="fc" id="L1402">    com.ibm.cloud.sdk.core.util.Validator.notNull(deployCartridgeOptions,</span>
      &quot;deployCartridgeOptions cannot be null&quot;);
<span class="pc bpc" id="L1404" title="1 of 2 branches missed.">    com.ibm.cloud.sdk.core.util.Validator.isTrue((deployCartridgeOptions.archiveFile() != null), &quot;At least one of  or archiveFile must be supplied.&quot;);</span>
<span class="fc" id="L1405">    String[] pathSegments = { &quot;v1/deploy&quot; };</span>
<span class="fc" id="L1406">    RequestBuilder builder = RequestBuilder.post(RequestBuilder.constructHttpUrl(getServiceUrl(), pathSegments));</span>
<span class="fc" id="L1407">    Map&lt;String, String&gt; sdkHeaders = SdkCommon.getSdkHeaders(&quot;annotator_for_clinical_data_acd&quot;, &quot;v1&quot;, &quot;deployCartridge&quot;);</span>
<span class="fc bfc" id="L1408" title="All 2 branches covered.">    for (Entry&lt;String, String&gt; header : sdkHeaders.entrySet()) {</span>
<span class="fc" id="L1409">      builder.header(header.getKey(), header.getValue());</span>
<span class="fc" id="L1410">    }</span>
<span class="fc" id="L1411">    builder.header(&quot;Accept&quot;, &quot;application/json&quot;);</span>
<span class="fc" id="L1412">    builder.query(&quot;version&quot;, this.version);</span>
<span class="pc bpc" id="L1413" title="1 of 2 branches missed.">    if (deployCartridgeOptions.update() != null) {</span>
<span class="fc" id="L1414">      builder.query(&quot;update&quot;, String.valueOf(deployCartridgeOptions.update()));</span>
    }
<span class="fc" id="L1416">    MultipartBody.Builder multipartBuilder = new MultipartBody.Builder();</span>
<span class="fc" id="L1417">    multipartBuilder.setType(MultipartBody.FORM);</span>
<span class="pc bpc" id="L1418" title="1 of 2 branches missed.">    if (deployCartridgeOptions.archiveFile() != null) {</span>
<span class="fc" id="L1419">      okhttp3.RequestBody archiveFileBody = RequestUtils.inputStreamBody(deployCartridgeOptions.archiveFile(), deployCartridgeOptions.archiveFileContentType());</span>
<span class="fc" id="L1420">      multipartBuilder.addFormDataPart(&quot;archive_file&quot;, &quot;filename&quot;, archiveFileBody);</span>
    }
<span class="fc" id="L1422">    builder.body(multipartBuilder.build());</span>
<span class="fc" id="L1423">    ResponseConverter&lt;DeployCartridgeResponse&gt; responseConverter =</span>
<span class="fc" id="L1424">      ResponseConverterUtils.getValue(new com.google.gson.reflect.TypeToken&lt;DeployCartridgeResponse&gt;() { }.getType());</span>
<span class="fc" id="L1425">    return createServiceCall(builder.build(), responseConverter);</span>
  }

  /**
   * Deploy a cartridge.
   *
   * Deploy a cartridge from a cartridge archive file.
   *
   * @return a {@link ServiceCall} with a result of type {@link DeployCartridgeResponse}
   */
  public ServiceCall&lt;DeployCartridgeResponse&gt; deployCartridge() {
<span class="nc" id="L1436">    return deployCartridge(null);</span>
  }

  /**
   * Determine if service is running correctly.
   *
   * This resource differs from /status in that it will will always return a 500 error if the service state is not OK.
   * This makes it simpler for service front ends (such as Datapower) to detect a failed service.
   *
   * @param getHealthCheckStatusOptions the {@link GetHealthCheckStatusOptions} containing the options for the call
   * @return a {@link ServiceCall} with a result of type {@link ServiceStatus}
   */
  public ServiceCall&lt;ServiceStatus&gt; getHealthCheckStatus(GetHealthCheckStatusOptions getHealthCheckStatusOptions) {
<span class="fc" id="L1449">    String[] pathSegments = { &quot;v1/status/health_check&quot; };</span>
<span class="fc" id="L1450">    RequestBuilder builder = RequestBuilder.get(RequestBuilder.constructHttpUrl(getServiceUrl(), pathSegments));</span>
<span class="fc" id="L1451">    Map&lt;String, String&gt; sdkHeaders = SdkCommon.getSdkHeaders(&quot;annotator_for_clinical_data_acd&quot;, &quot;v1&quot;, &quot;getHealthCheckStatus&quot;);</span>
<span class="fc bfc" id="L1452" title="All 2 branches covered.">    for (Entry&lt;String, String&gt; header : sdkHeaders.entrySet()) {</span>
<span class="fc" id="L1453">      builder.header(header.getKey(), header.getValue());</span>
<span class="fc" id="L1454">    }</span>
<span class="pc bpc" id="L1455" title="1 of 2 branches missed.">    if (getHealthCheckStatusOptions != null) {</span>
<span class="pc bpc" id="L1456" title="1 of 2 branches missed.">      if (getHealthCheckStatusOptions.accept() != null) {</span>
<span class="fc" id="L1457">        builder.header(&quot;Accept&quot;, getHealthCheckStatusOptions.accept());</span>
      }
<span class="pc bpc" id="L1459" title="1 of 2 branches missed.">      if (getHealthCheckStatusOptions.format() != null) {</span>
<span class="fc" id="L1460">        builder.query(&quot;format&quot;, getHealthCheckStatusOptions.format());</span>
      }
    }
<span class="fc" id="L1463">    ResponseConverter&lt;ServiceStatus&gt; responseConverter =</span>
<span class="fc" id="L1464">      ResponseConverterUtils.getValue(new com.google.gson.reflect.TypeToken&lt;ServiceStatus&gt;() { }.getType());</span>
<span class="fc" id="L1465">    return createServiceCall(builder.build(), responseConverter);</span>
  }

  /**
   * Determine if service is running correctly.
   *
   * This resource differs from /status in that it will will always return a 500 error if the service state is not OK.
   * This makes it simpler for service front ends (such as Datapower) to detect a failed service.
   *
   * @return a {@link ServiceCall} with a result of type {@link ServiceStatus}
   */
  public ServiceCall&lt;ServiceStatus&gt; getHealthCheckStatus() {
<span class="nc" id="L1477">    return getHealthCheckStatus(null);</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>